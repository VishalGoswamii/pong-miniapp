<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Pong • Classic</title>

<!-- Farcaster Mini App -->
<meta name="fc:miniapp" content='{
  "version": "1",
  "imageUrl": "https://pong-miniapp.vercel.app/og.png",
  "button": {
    "title": "Play Pong",
    "action": {
      "type": "launch_frame",
      "name": "Pong",
      "url": "https://pong-miniapp.vercel.app/",
      "splashImageUrl": "https://pong-miniapp.vercel.app/icon-200.png",
      "splashBackgroundColor": "#0f172a"
    }
  }
}' />

<!-- (Optional) PeerJS: kept only so Online Classic still works if you wired /api/match -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.5/peerjs.min.js" defer></script>

<style>
:root{
  --courtOuter:#061429; --courtMain:#1E40AF; --courtKitchen:#ef4444; --courtLine:#F8FAFC;
  --centerRed:#ef4444; --ballY:#FDE047; --paddleFace:#D4DEE9; --paddleEdge:#425C7A;
}
html,body{margin:0;height:100%;background:var(--courtOuter);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
#wrap{position:fixed;inset:0;z-index:0}
canvas{display:block;width:100%;height:100%;touch-action:none}

/* HUD */
#score{position:fixed;top:calc(env(safe-area-inset-top) + 10px);left:50%;transform:translateX(-50%);
  color:#fff;font-weight:1000;letter-spacing:1.2px;font-size:26px;padding:8px 14px;border-radius:16px;
  background:linear-gradient(135deg,rgba(255,255,255,.14),rgba(255,255,255,.07));
  box-shadow:inset 0 0 0 1px rgba(255,255,255,.16),0 14px 40px rgba(0,0,0,.45)}
#score.bump{animation:bump .18s ease}
@keyframes bump{50%{transform:translateX(-50%) scale(1.08)}}
#hs{position:fixed;top:calc(env(safe-area-inset-top) + 10px);right:10px;color:#fff;
  font-weight:900;font-size:12px;padding:6px 10px;border-radius:12px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.15)}

/* Overlay */
#overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:2}
#overlay.hidden{display:none}
.card{background:rgba(12,18,32,.86);border:1px solid rgba(255,255,255,.14);color:#e9f1ff;padding:24px 18px;border-radius:18px;text-align:center;
  box-shadow:0 28px 90px rgba(0,0,0,.55);max-width:680px;margin:20px}
.title{margin:6px 0 2px;font-size:30px;font-weight:1000;color:#fff}
.sub{margin-top:6px;opacity:.85;font-size:14px}
.mode-grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:10px}
.mode{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px;border:1px solid rgba(255,255,255,.18);border-radius:14px;background:rgba(255,255,255,.05)}
.mode h3{margin:0;font-size:18px}
.mode p{margin:0;font-size:13px;opacity:.9}
button{padding:12px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.18);font-weight:900;font-size:15px;cursor:pointer}
.primary{color:#08111a;background:#60A5FA;box-shadow:0 8px 24px rgba(37,99,235,.45),inset 0 0 0 1px rgba(255,255,255,.18)}

#hint{position:fixed;bottom:calc(env(safe-area-inset-bottom) + 10px);left:0;right:0;text-align:center;color:#e7f2ff;font-size:13px;opacity:.9}

/* Player badges (pfp/name) */
#players{position:fixed;top:calc(env(safe-area-inset-top) + 54px);left:0;right:0;display:flex;justify-content:space-between;padding:0 10px;pointer-events:none}
.pb{display:flex;align-items:center;gap:8px;background:rgba(12,18,32,.6);border:1px solid rgba(255,255,255,.14);
  color:#eaf3ff;padding:6px 10px;border-radius:999px;min-width:120px}
.pb img{width:24px;height:24px;border-radius:999px;object-fit:cover;background:#0f172a}
.pb .name{font-weight:800;font-size:13px}
.pb .tag{font-size:12px;opacity:.8}

/* Toast */
#toast{position:fixed;top:calc(env(safe-area-inset-top) + 10px);right:10px;color:#fff;background:rgba(0,0,0,.6);padding:8px 10px;border-radius:10px;font-size:12px;display:none}
#toast.show{display:block}
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Pong"></canvas></div>
  <div id="score" aria-live="polite">0 : 0 • 0 pts</div>
  <div id="hs">HS 0</div>

  <div id="players">
    <div class="pb"><img id="p1img" alt=""><div><div class="name" id="p1name">You</div><div class="tag">P1</div></div></div>
    <div class="pb"><img id="p2img" alt=""><div><div class="name" id="p2name">CPU</div><div class="tag" id="p2tag">AI</div></div></div>
  </div>

  <div id="overlay">
    <div class="card home">
      <h1 class="title">PONG</h1>
      <p class="sub">Classic rally • Pickleball blue court</p>

      <div class="mode-grid">
        <div class="mode">
          <div>
            <h3>Single Player (vs AI)</h3>
            <p>Drag anywhere to move • Win by 2</p>
          </div>
          <button class="primary" id="btnSingle">Play</button>
        </div>

        <div class="mode">
          <div>
            <h3>Online 1v1 (Classic)</h3>
            <p>Quick match (requires your match server)</p>
          </div>
          <button class="primary" id="btnFind">Find Match</button>
        </div>
      </div>
    </div>
  </div>

  <div id="hint">Swipe/drag to move. Points & High Score are saved on your device.</div>
  <div id="toast"></div>

<script>
'use strict';
/* ========== DOM ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false }) || canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const hsEl = document.getElementById('hs');
const overlay = document.getElementById('overlay');
const btnSingle = document.getElementById('btnSingle');
const btnFind = document.getElementById('btnFind');
const p1img = document.getElementById('p1img'), p1name = document.getElementById('p1name');
const p2img = document.getElementById('p2img'), p2name = document.getElementById('p2name'), p2tag = document.getElementById('p2tag');
const toast = document.getElementById('toast');
const vib = (ms)=>{ try{ if(navigator.vibrate) navigator.vibrate(ms);}catch(e){} };
function showToast(t){ toast.textContent=t; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 2200); }

/* Farcaster user for badge */
function readMiniUser(){
  try{
    const c = (window.__fc_sdk && window.__fc_sdk.context) || (window.farcaster && window.farcaster.sdk && window.farcaster.sdk.context) ||
              (window.frame && window.frame.sdk && window.frame.sdk.context) || (window.sdk && window.sdk.context);
    return c && c.user || null;
  }catch(e){ return null; }
}
function setPlayerBadge(elImg, elName, obj, fallback){
  if (obj){ elName.textContent = obj.displayName || obj.username || ('fid ' + obj.fid); if (obj.pfpUrl){ elImg.src=obj.pfpUrl; elImg.alt=elName.textContent; } else { elImg.removeAttribute('src'); } }
  else { elName.textContent = fallback || 'Guest'; elImg.removeAttribute('src'); }
}
const me = readMiniUser(); setPlayerBadge(p1img, p1name, me, 'You');

/* ========== Game State ========== */
const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
let W=0, H=0, last=0, running=false, paused=false, noScoreUntil=0;

const paddle = { w: 4*dpr, h: 70*dpr };
let playerY=0, oppY=0;

const ball = { x:0, y:0, r:10, vx:0, vy:0, baseSpeed:360 };

let scoreL=0, scoreR=0;
const POINTS_TO_WIN = 11; // win by 2 below

// AI tuning (kept human-friendly)
let aiOn = true, aiSpeed = 310*dpr, aiReact = 0.085, aiTimer = 0, aiAimY = 0, aiNoise = 28*dpr;

// Player-friendly tweaks
const playerHitboxBonus = 10*dpr;
const aiHitboxTight = 8*dpr;

// Trail
const trail = [];

// Spin swipe
let lastPointerY=null, pointerVy=0;

// Anti-stall
let flatTimer=0;

// ===== Points & Highscore =====
let points = 0;
let highscore = Number(localStorage.getItem('pong_highscore') || 0);
// Tunables:
const PTS_HIT = 5;
const PTS_GOAL = 100;
const PTS_WIN = 250;

function updateHUD(){
  scoreEl.textContent = `${scoreL} : ${scoreR} • ${points} pts`;
  hsEl.textContent = `HS ${highscore}`;
}
function maybeUpdateHighScore(){
  if (points > highscore){
    highscore = points;
    localStorage.setItem('pong_highscore', String(highscore));
    showToast('✨ New High Score!');
    updateHUD();
  }
}

/* ========== Resize/init ========== */
function resize(){
  const w = innerWidth, h = innerHeight;
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  W = canvas.width; H = canvas.height;
  paddle.h = Math.max(56*dpr, Math.min(H*0.16, 86*dpr)) * 0.90;
  if (!running && last===0){ playerY=H/2; oppY=H/2; ball.x=W/2; ball.y=H/2; }
  noScoreUntil = performance.now() + 250;
  draw();
}
addEventListener('resize', resize);

const clamp=(v,min,max)=>v<min?min:v>max?max:v;
const css=(name)=>getComputedStyle(document.documentElement).getPropertyValue(name).trim();

/* ========== Serve/reset ========== */
function resetBall(dir=1){
  ball.x=W/2; ball.y=H/2;
  const angle=(Math.random()*0.5 - 0.25);
  const sp = ball.baseSpeed * dpr;
  ball.vx=Math.cos(angle)*sp*dir; ball.vy=Math.sin(angle)*sp;
  playerY=H/2; oppY=H/2;
  noScoreUntil = performance.now() + 200;
  trail.length=0;
}

/* ========== Input (pointer/touch) ========== */
function updateFromPointerLike(clientY){
  const r = canvas.getBoundingClientRect();
  const y = (clientY - r.top) * dpr;
  if (lastPointerY != null) pointerVy = (y - lastPointerY);
  lastPointerY = y;
  playerY = clamp(y, paddle.h/2, H - paddle.h/2);
  if (NETMODE==='online-guest' && conn && conn.open) { try{ conn.send({ t:'in', y: playerY }); }catch(e){} }
}
function onPointer(e){ updateFromPointerLike(e.clientY); e.preventDefault(); }
function onTouch(e){ if (!e.touches?.[0]) return; updateFromPointerLike(e.touches[0].clientY); e.preventDefault(); }

let dragging=false;
canvas.addEventListener('pointerdown',(e)=>{dragging=true;if(!running) startSingleIfNeeded(); onPointer(e);},{passive:false});
canvas.addEventListener('pointermove',(e)=>{if(!dragging)return;onPointer(e);},{passive:false});
canvas.addEventListener('pointerup',()=>{dragging=false;lastPointerY=null;pointerVy=0;},{passive:true});
canvas.addEventListener('pointercancel',()=>{dragging=false;lastPointerY=null;pointerVy=0;},{passive:true});

canvas.addEventListener('touchstart',(e)=>{dragging=true;if(!running) startSingleIfNeeded(); onTouch(e);},{passive:false});
canvas.addEventListener('touchmove',(e)=>{if(!dragging)return;onTouch(e);},{passive:false});
canvas.addEventListener('touchend',()=>{dragging=false;lastPointerY=null;pointerVy=0;},{passive:true});
canvas.addEventListener('touchcancel',()=>{dragging=false;lastPointerY=null;pointerVy=0;},{passive:true});

function startSingleIfNeeded(){ if (NETMODE==='single' && !running) startGame(); }

/* ========== Render ========== */
function drawCourt(){
  ctx.fillStyle=css('--courtOuter'); ctx.fillRect(0,0,W,H);
  ctx.fillStyle=css('--courtMain');  ctx.fillRect(0,0,W,H);
  const kW = W * (7/44);
  ctx.fillStyle=css('--courtKitchen'); ctx.fillRect(W/2 - kW, 0, kW, H); ctx.fillRect(W/2, 0, kW, H);
  ctx.save(); ctx.strokeStyle=css('--courtLine'); ctx.lineWidth=3*dpr; ctx.lineCap='square';
  ctx.strokeRect(1.5*dpr,1.5*dpr,W-3*dpr,H-3*dpr);
  ctx.setLineDash([10*dpr,14*dpr]); ctx.strokeStyle=css('--centerRed'); ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
  ctx.setLineDash([]); ctx.strokeStyle=css('--courtLine');
  ctx.beginPath(); ctx.moveTo(W/2 - kW,0); ctx.lineTo(W/2 - kW,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W/2 + kW,0); ctx.lineTo(W/2 + kW,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();
  ctx.restore();
}
function drawPaddle(x,y,w,h){
  ctx.fillStyle=css('--paddleFace');
  const r=Math.min(6*dpr,w);
  ctx.beginPath();
  ctx.moveTo(x, y-h/2+r);
  ctx.arcTo(x, y-h/2, x+w, y-h/2, r);
  ctx.arcTo(x+w, y-h/2, x+w, y+h/2, r);
  ctx.arcTo(x+w, y+h/2, x, y+h/2, r);
  ctx.arcTo(x, y+h/2, x, y-h/2, r);
  ctx.closePath(); ctx.fill();
  ctx.lineWidth=1*dpr; ctx.strokeStyle=css('--paddleEdge'); ctx.stroke();
}
function drawBall(){
  // trail
  for (let i=0;i<trail.length;i++){
    const t=i/trail.length;
    ctx.globalAlpha=t*0.5;
    ctx.beginPath(); ctx.arc(trail[i].x, trail[i].y, (ball.r*dpr)*(0.6+0.4*t), 0, Math.PI*2);
    ctx.fillStyle=css('--ballY'); ctx.fill();
  }
  ctx.globalAlpha=1;
  const rr=ball.r*dpr;
  ctx.fillStyle=css('--ballY'); ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.fill();
  ctx.lineWidth=1.2*dpr; ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.stroke();
}
function draw(){
  drawCourt();
  const px=22*dpr, ax=W-(22*dpr + paddle.w);
  drawPaddle(px, playerY, paddle.w, paddle.h);
  drawPaddle(ax, oppY,     paddle.w, paddle.h);
  drawBall();
}

/* ========== Step (host or single) ========== */
function step(dt){
  const oldX = ball.x;
  const r = ball.r*dpr;
  ball.x += ball.vx*dt; ball.y += ball.vy*dt;

  // trail + anti-stall
  trail.push({x:ball.x,y:ball.y}); if (trail.length>10) trail.shift();
  if (Math.abs(ball.vy) < 30*dpr) flatTimer += dt; else flatTimer = 0;
  if (flatTimer > 1.0) { ball.vy += (Math.random()>0.5?1:-1)*50*dpr; flatTimer = 0; }

  // walls
  if (ball.y < r){ ball.y = r; ball.vy *= -1; }
  if (ball.y > H - r){ ball.y = H - r; ball.vy *= -1; }

  // paddles (with small fairness bias)
  const px = 22*dpr, ax = W - (22*dpr + paddle.w);
  const pTop = (playerY - paddle.h/2) - playerHitboxBonus, pBot = (playerY + paddle.h/2) + playerHitboxBonus;
  const aTop = (oppY    - paddle.h/2) + aiHitboxTight,     aBot = (oppY    + paddle.h/2) - aiHitboxTight;

  if (ball.vx < 0){
    if (ball.x - r <= px + paddle.w && ball.x - r >= px && ball.y >= pTop && ball.y <= pBot){
      ball.x = px + paddle.w + r;
      const t = (ball.y - playerY) / (paddle.h/2);
      ball.vx = Math.abs(ball.vx) * 1.02;
      ball.vy = (ball.vy * 0.45) + (t * 240 * dpr);
      // spin from swipe
      ball.vy += pointerVy * 5; pointerVy = 0;
      // clamp bounce angle + max speed
      clampBounceAndSpeed(+1);
      // === POINTS: paddle hit ===
      points += PTS_HIT; updateHUD();
      vib(8);
    }
  } else {
    if (ball.x + r >= ax && ball.x + r <= ax + paddle.w && ball.y >= aTop && ball.y <= aBot){
      ball.x = ax - r;
      const t = (ball.y - oppY) / (paddle.h/2);
      ball.vx = -Math.abs(ball.vx) * 0.98; // AI shaves a bit
      ball.vy = (ball.vy * 0.45) + (t * 230 * dpr);
      clampBounceAndSpeed(-1);
      vib(6);
    }
  }

  // scoring after grace
  if (performance.now() >= noScoreUntil){
    const leftOut  = (ball.vx < 0) && ((oldX + r) >= 0) && ((ball.x + r) < 0);
    const rightOut = (ball.vx > 0) && ((oldX - r) <= W) && ((ball.x - r) > W);
    if (leftOut){ score('R'); return; }
    if (rightOut){ score('L'); return; }
  }

  // AI move
  if (aiOn){
    aiTimer += dt;
    if (aiTimer >= aiReact){
      aiTimer = 0;
      if (ball.vx > 0){
        const axX = W - (22*dpr + paddle.w);
        const timeToReach = Math.max(0.001, (axX - ball.x) / Math.max(80, ball.vx));
        let projY = ball.y + ball.vy * timeToReach;
        const hh = H - ball.r*dpr;
        while (projY < ball.r*dpr || projY > hh){
          if (projY < ball.r*dpr) projY = ball.r*dpr + (ball.r*dpr - projY);
          else if (projY > hh)    projY = hh - (projY - hh);
        }
        const diff = scoreL - scoreR;
        const baseErr = (diff <= -2) ? 34*dpr : (diff >= 2 ? 10*dpr : 20*dpr);
        const jitter = (Math.random()*2 - 1) * baseErr;
        aiAimY = clamp(projY + jitter, paddle.h/2, H - paddle.h/2);
      } else { aiAimY = H/2; }
    }
    const dy = aiAimY - oppY;
    const maxStep = aiSpeed * dt;
    oppY += clamp(dy, -maxStep, maxStep);
    oppY = clamp(oppY, paddle.h/2, H - paddle.h/2);
  }

  // clamp player
  playerY = clamp(playerY, paddle.h/2, H - paddle.h/2);

  draw();

  // net sync (if online host)
  if (NETMODE==='online-host' && conn && conn.open){
    const now = performance.now();
    if (now - netLastSend > 33){
      netLastSend = now;
      try{ conn.send({ t:'st', x:ball.x, y:ball.y, vx:ball.vx, vy:ball.vy, p1:playerY, p2:oppY, sl:scoreL, sr:scoreR, w:W, h:H }); }catch(e){}
    }
  }
}

function clampBounceAndSpeed(dirSign){
  // dirSign: +1 to the right, -1 to left
  const speed = Math.hypot(ball.vx, ball.vy);
  let angle = Math.atan2(ball.vy, Math.abs(ball.vx));
  const maxAngle = Math.PI * 0.36; // ~65°
  angle = Math.max(-maxAngle, Math.min(maxAngle, angle));
  ball.vx = Math.cos(angle) * speed * (dirSign>0?1:-1);
  ball.vy = Math.sin(angle) * speed;
  const maxSp = ball.baseSpeed * dpr * 1.30;
  const curSp = Math.hypot(ball.vx, ball.vy);
  if (curSp > maxSp){ const m = maxSp/curSp; ball.vx*=m; ball.vy*=m; }
}

/* ========== Score / End ========== */
function score(side){ // 'L' means you scored; 'R' AI scored
  if (side==='L'){ scoreL++; points += PTS_GOAL; } else { scoreR++; }
  updateHUD();
  scoreEl.classList.remove('bump'); void scoreEl.offsetWidth; scoreEl.classList.add('bump');

  // adaptive AI & comeback assist (kept)
  const diff = scoreL - scoreR;
  if      (diff <= -2){ aiSpeed = 280*dpr; aiNoise = 34*dpr; aiReact = 0.095; ball.r = 12; }
  else if (diff >= 2){  aiSpeed = 340*dpr; aiNoise = 22*dpr; aiReact = 0.075; ball.r = 9; }
  else {                aiSpeed = 310*dpr; aiNoise = 28*dpr; aiReact = 0.085; ball.r = 10; }

  // win by 2
  const lead = Math.abs(scoreL - scoreR);
  if ((scoreL >= POINTS_TO_WIN || scoreR >= POINTS_TO_WIN) && lead >= 2){
    if (scoreL > scoreR) { points += PTS_WIN; updateHUD(); }
    maybeUpdateHighScore();
    running=false; overlay.classList.remove('hidden');
    const t = document.querySelector('.card.home .title'); if (t) t.textContent = (scoreL > scoreR ? 'You win!' : 'You lose');
    setTimeout(()=>{ const tt=document.querySelector('.card.home .title'); if (tt) tt.textContent='PONG'; }, 1200);
    vib(20);
    return;
  }

  vib(12);
  // serve toward trailing side (feels fair)
  const serveDir = (scoreL < scoreR) ? -1 : 1;
  resetBall(serveDir);
}

/* ========== Loop ========== */
function loop(ts){
  const dt = Math.min(0.02, ((last===0? ts-16 : ts) - last)/1000 || 0.016);
  last = ts;
  if (!paused){
    if (NETMODE==='single' || NETMODE==='online-host') step(dt);
    if (NETMODE==='online-guest') draw();
  }
  if (running) requestAnimationFrame(loop);
}

/* ========== Start flows ========== */
let NETMODE = 'home', peer=null, conn=null, isHost=false, netLastSend=0;
function startGame(){
  scoreL=0; scoreR=0; points=0; updateHUD();
  playerY=H/2; oppY=H/2; ball.r=10; flatTimer=0;
  aiSpeed=300*dpr; aiNoise=30*dpr; aiReact=0.09;
  resetBall(-1); // first serve to player
  overlay.classList.add('hidden');
  paused=false; running=true; last=0;
  requestAnimationFrame(loop);
}
function setBadgesForSingle(){
  setPlayerBadge(p1img, p1name, me, 'You');
  setPlayerBadge(p2img, p2name, { displayName:'CPU' }, 'CPU'); p2tag.textContent='AI';
}

document.getElementById('btnSingle').addEventListener('click', ()=>{
  NETMODE='single'; aiOn=true; setBadgesForSingle(); startGame();
});

document.getElementById('btnFind').addEventListener('click', ()=>{
  if (!window.Peer){ showToast('Loading network libs…'); return; }
  showToast('Looking for an opponent…');
  findMatchOnline();
});

/* ========== Online Classic (optional; requires your /api/match) ========== */
function findMatchOnline(){
  isHost=false; peer=new Peer();
  peer.on('connection', c=>{
    NETMODE='online-host'; aiOn=false; conn=c;
    setPlayerBadge(p1img, p1name, me, 'You'); setPlayerBadge(p2img, p2name, null, 'Player 2'); p2tag.textContent='P2';
    overlay.classList.add('hidden');
    conn.on('data', onNetDataFromGuest); conn.on('close', ()=>{ showToast('Player left'); endOnline(); });
    startGame();
  });
  peer.on('error', e=>{ showToast('Network error'); console.warn(e); endOnline(); });
  peer.on('open', async(id)=>{
    let resp; const u = me || {};
    try{
      resp = await fetch('/api/match',{method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({peerId:id, user:{fid:u.fid, username:u.username, displayName:u.displayName, pfpUrl:u.pfpUrl}})}).then(r=>r.json());
    }catch(e){ showToast('Match server unreachable'); return endOnline(); }
    if (resp?.opponentPeerId){
      NETMODE='online-guest'; aiOn=false; overlay.classList.add('hidden');
      conn = peer.connect(resp.opponentPeerId);
      conn.on('open',()=>{ running=true; last=0; requestAnimationFrame(loop); });
      conn.on('data', onNetDataFromHost); conn.on('close', ()=>{ showToast('Disconnected'); endOnline(); });
      setPlayerBadge(p2img, p2name, me, 'You'); p2tag.textContent='P2';
    } else if (resp?.wait){ showToast('Waiting for opponent…'); }
    else { showToast('Match error'); endOnline(); }
  });
}
function endOnline(){ running=false; overlay.classList.remove('hidden'); try{conn&&conn.close();}catch(e){} try{peer&&peer.destroy();}catch(e){} conn=null; peer=null; NETMODE='home'; }
function onNetDataFromGuest(msg){ if (!msg||typeof msg!=='object') return; if (msg.t==='in'){ oppY = clamp(msg.y, paddle.h/2, H - paddle.h/2); } }
function onNetDataFromHost(msg){
  if (!msg||typeof msg!=='object') return;
  if (msg.t==='st'){ ball.x=msg.x; ball.y=msg.y; ball.vx=msg.vx; ball.vy=msg.vy; playerY=msg.p1; oppY=msg.p2; scoreL=msg.sl; scoreR=msg.sr; updateHUD(); if (W!==msg.w||H!==msg.h) resize(); draw(); }
}

/* ========== Boot ========== */
function init(){ resize(); updateHUD(); draw(); }
init();

/* ========== Farcaster: hide splash when ready ========== */
(function(){
  function callReadyFrom(obj){ try{ if(obj && obj.actions && typeof obj.actions.ready==='function'){ obj.actions.ready(); return true; } }catch(e){} return false; }
  function tryAll(){ if (callReadyFrom(window.__fc_sdk)) return true; if (window.farcaster && callReadyFrom(window.farcaster.sdk)) return true; if (window.frame && callReadyFrom(window.frame.sdk)) return true; if (callReadyFrom(window.sdk)) return true; return false; }
  if (!tryAll()){ requestAnimationFrame(()=>requestAnimationFrame(tryAll)); let n=0,t=setInterval(()=>{ if (tryAll() || ++n>60) clearInterval(t); },100); }
})();
</script>
</body>
</html>
