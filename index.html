<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>RETROPONG ‚Äî Farcaster Mini App</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

  <!-- Farcaster Mini App Embed -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://your-domain.com/og-1200x800.png",
    "button":{
      "title":"Play RetroPong",
      "action":{
        "type":"launch_frame",
        "name":"RETROPONG",
        "url":"https://your-domain.com/",
        "splashImageUrl":"https://your-domain.com/icon-200.png",
        "splashBackgroundColor":"#0a0f0a"
      }
    }
  }'/>
  <!-- Back-compat -->
  <meta name="fc:frame" content='{
    "version":"1",
    "imageUrl":"https://your-domain.com/og-1200x800.png",
    "button":{
      "title":"Play RetroPong",
      "action":{
        "type":"launch_frame",
        "name":"RETROPONG",
        "url":"https://your-domain.com/",
        "splashImageUrl":"https://your-domain.com/icon-200.png",
        "splashBackgroundColor":"#0a0f0a"
      }
    }
  }'/>

  <style>
    :root{
      --bg:#0b0f10;         /* tube black */
      --crt:#0e1416;        /* panel */
      --grid:#101719;
      --bright:#dfffc7;     /* bright green */
      --dim:#7aff9b;        /* dim green */
      --accent:#ffdd7a;     /* amber highlights */
      --line:#c8ffb4;
      --scan:rgba(255,255,255,0.04);
      --glass:rgba(255,255,255,0.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--bright)}
    body{font:600 14px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

    /* layout */
    .wrap{position:fixed;inset:env(safe-area-inset-top,0) 0 env(safe-area-inset-bottom,0) 0;display:grid;place-items:center}
    .shell{
      position:relative;
      width:min(100vw, 100vh); height:min(100vw,100vh);
      background:linear-gradient(180deg,var(--crt),#0a0e0f);
      border:2px solid #0f1a1b; border-radius:18px;
      box-shadow:
        inset 0 0 0 1px #172427,
        0 18px 60px rgba(0,0,0,.6),
        0 8px 24px rgba(0,0,0,.45);
      overflow:hidden;
    }
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block; background:transparent}

    /* scanlines + vignette */
    .scan{
      pointer-events:none; position:absolute; inset:0;
      background:
        repeating-linear-gradient(0deg, transparent 0 2px, var(--scan) 2px 3px);
      mix-blend-mode:soft-light;
      opacity:.8;
    }
    .vignette{
      pointer-events:none; position:absolute; inset:-10%;
      background:radial-gradient(ellipse at center, rgba(0,0,0,0) 60%, rgba(0,0,0,.35) 85%, rgba(0,0,0,.6) 100%);
    }

    /* score plates */
    .scores{position:absolute; left:0; right:0; top:12px; display:flex; justify-content:space-between; padding:0 10%}
    .plate{
      background:linear-gradient(180deg,rgba(208,255,184,.12),rgba(0,0,0,.1));
      border:1px solid rgba(140,255,160,.25); border-radius:12px;
      padding:6px 12px; color:var(--bright);
      font:900 clamp(28px, 8vw, 56px)/1.0 ui-monospace, monospace;
      text-shadow:0 0 8px rgba(160,255,195,.25);
      backdrop-filter:blur(6px);
      min-width:64px; text-align:center;
    }

    /* bottom HUD */
    .hud{
      position:absolute; left:0; right:0; bottom:10px; text-align:center;
      color:var(--dim); letter-spacing:.06em; text-transform:uppercase;
      font:700 clamp(10px,2.5vw,12px)/1 ui-monospace, monospace;
      opacity:.9;
    }

    /* overlay menu */
    .overlay{position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background:linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.6));
      backdrop-filter:blur(4px);
    }
    .overlay.show{display:flex}
    .card{
      width:min(92%,520px); color:var(--bright);
      background:linear-gradient(180deg, rgba(100,255,150,.06), rgba(0,0,0,.1));
      border:1px solid rgba(120,255,180,.22); border-radius:14px;
      box-shadow:0 16px 60px rgba(0,0,0,.5), inset 0 1px 0 var(--glass);
      padding:18px;
    }
    .title{margin:0 0 6px 0; font:900 22px/1.1 ui-monospace, monospace; letter-spacing:.04em}
    .subtitle{margin:0 0 12px 0; color:var(--dim); font-weight:700}
    .row{display:flex; flex-wrap:wrap; gap:10px}
    .btn{
      appearance:none; cursor:pointer;
      background:linear-gradient(180deg, #0f2016, #0a1610);
      border:1px solid #1e3a2c; color:var(--bright);
      border-radius:10px; padding:10px 12px; font:800 13px/1 ui-monospace, monospace; letter-spacing:.04em;
      box-shadow:inset 0 1px 0 var(--glass), 0 6px 18px rgba(0,0,0,.35);
    }
    .btn:active{transform:translateY(1px)}
    .amber{border-color:#3f3312; color:#ffd98a; background:linear-gradient(180deg,#31270f,#1c1608)}
    .ghost{background:transparent}
    .note{opacity:.85; color:#c1ffd9; font-weight:700; margin-top:10px}

    /* tiny bezel ticks */
    .ticks{
      position:absolute; inset:0; pointer-events:none; opacity:.25;
      background:
        linear-gradient(90deg, transparent 0 calc(50% - 1px), rgba(255,255,255,.35) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 1px)),
        linear-gradient(0deg, transparent 0 calc(50% - 1px), rgba(255,255,255,.35) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 1px));
      mix-blend-mode:overlay;
    }
  </style>

  <!-- Farcaster Mini App SDK -->
  <script defer src="https://cdn.jsdelivr.net/npm/@farcaster/miniapp-sdk/dist/index.umd.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="shell" id="shell">
      <canvas id="game" aria-label="RETROPONG"></canvas>
      <div class="ticks"></div>
      <div class="scan"></div>
      <div class="vignette"></div>

      <!-- UI layers -->
      <div class="scores">
        <div id="scL" class="plate">0</div>
        <div id="scR" class="plate">0</div>
      </div>
      <div id="hud" class="hud"></div>

      <!-- Overlay menu (shown on load, pause, or game over) -->
      <div id="overlay" class="overlay" aria-hidden="true">
        <div class="card">
          <h1 class="title" id="ovTitle">RETROPONG</h1>
          <div class="subtitle" id="ovSub">First to 11 ‚Ä¢ Arrow keys / drag to move</div>
          <div class="row" style="margin-bottom:10px">
            <button id="playBtn"  class="btn">‚ñ∂ Start</button>
            <button id="againBtn" class="btn" style="display:none">‚ñ∂ Play Again</button>
            <button id="pauseBtn" class="btn ghost">‚èØ Pause/Resume</button>
          </div>
          <div class="row">
            <button id="addBtn"   class="btn">‚ûï Add to Farcaster</button>
            <button id="shareBtn" class="btn amber">üì£ Share High Score</button>
            <button id="closeBtn" class="btn ghost">‚úï Close</button>
          </div>
          <div class="note">Pro tip: rallies speed up the ball. Good luck, pilot.</div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  'use strict';

  /* ===== Farcaster SDK (robust + late ready) ===== */
  let fc=null, readySent=false;
  function setupSDK(){
    if(window.FarcasterMiniApp && !fc){
      fc = new window.FarcasterMiniApp.MiniAppSDK();
      // We'll call fc.actions.ready() after first paint in draw()
      fc.context().catch(()=>{});
    }
  }
  document.addEventListener('DOMContentLoaded', setupSDK);
  function signalReadyOnce(){
    if(readySent) return;
    readySent = true;
    if(fc){ try{ fc.actions.ready(); }catch(e){} }
  }

  /* ===== DOM ===== */
  const canvas = document.getElementById('game');
  const shell  = document.getElementById('shell');
  const ctx = canvas.getContext('2d',{alpha:false, desynchronized:true});
  const hud = document.getElementById('hud');
  const scL = document.getElementById('scL');
  const scR = document.getElementById('scR');

  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovSub   = document.getElementById('ovSub');
  const playBtn = document.getElementById('playBtn');
  const againBtn= document.getElementById('againBtn');
  const pauseBtn= document.getElementById('pauseBtn');
  const addBtn  = document.getElementById('addBtn');
  const shareBtn= document.getElementById('shareBtn');
  const closeBtn= document.getElementById('closeBtn');

  /* ===== Config (retro feel) ===== */
  const WIN_SCORE = 11;
  const DPR_MIN=1, DPR_MAX=2, FIXED_DT=1/60, MAX_ACCUM=0.25;

  // sizes & speeds (tuned)
  const BALL=10;
  const SPEED_BALL=245, SPEED_AI=320, SPEED_PADDLE=380;

  // dotted midline
  let DOT_H=10, DOT_G=10;

  // paddles scale with canvas, but kept slim for skill
  let P_W=16, P_H=0, P_R=6;

  const state = {
    dpr:1, cssW:0, cssH:0, last:0, accum:0,
    lY:0, rY:0,
    scoreL:0, scoreR:0, rally:0,
    counting:false, t0:0,
    paused:true, gameover:false,
    balls:[],
  };

  function clamp(v,a,b){ return v<a?a:v>b?b:v; }

  function sizeCanvas(){
    const r = canvas.getBoundingClientRect();
    const dpr = clamp(window.devicePixelRatio||1, DPR_MIN, DPR_MAX);
    if (state.cssW===r.width && state.cssH===r.height && state.dpr===dpr) return;
    state.cssW = r.width|0; state.cssH = r.height|0; state.dpr = dpr;
    canvas.width  = Math.max(1, Math.floor(state.cssW*dpr));
    canvas.height = Math.max(1, Math.floor(state.cssH*dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled=false;

    // scale UI with size
    P_W = Math.max(12, Math.round(state.cssW*0.018));
    P_H = Math.max(120, Math.round(state.cssH*0.45));
    P_R = Math.round(P_W*0.45);

    DOT_H = Math.max(8, Math.round(state.cssH*0.014));
    DOT_G = DOT_H;
  }

  function roundedRect(x,y,w,h,r){
    const rr=Math.min(r,Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function resetPositions(){
    state.lY = (state.cssH - P_H)/2;
    state.rY = (state.cssH - P_H)/2;
    spawnBall(Math.random()<0.5?-1:1);
  }

  function spawnBall(dir){
    const ay = clamp(Math.random()*2-1, -0.72, 0.72);
    const s = SPEED_BALL * (1 + Math.min(0.012*state.rally, 0.6));
    const vx = dir * s * Math.sqrt(1-ay*ay);
    const vy = s * ay;
    state.balls = [{x:(state.cssW-BALL)/2, y:(state.cssH-BALL)/2, vx, vy}];
  }

  /* ===== Sim ===== */
  const keys={up:false,down:false}; let pointerY=null;

  function stepBall(b, dt){
    b.x += b.vx*dt; b.y += b.vy*dt;

    // walls
    if (b.y <= 0){ b.y = 0; b.vy = Math.abs(b.vy); }
    else if (b.y+BALL >= state.cssH){ b.y = state.cssH-BALL; b.vy = -Math.abs(b.vy); }

    // paddles
    if (b.x <= P_W+12){
      if (b.y+BALL>=state.lY && b.y<=state.lY+P_H){
        b.x = P_W+12;
        b.vx = Math.abs(b.vx)*1.045;
        const rel=((b.y+BALL/2)-(state.lY+P_H/2))/(P_H/2);
        b.vy += rel*95; state.rally++;
      }
    }
    const rx = state.cssW - (P_W+12) - BALL;
    if (b.x >= rx){
      if (b.y+BALL>=state.rY && b.y<=state.rY+P_H){
        b.x = rx;
        b.vx = -Math.abs(b.vx)*1.045;
        const rel=((b.y+BALL/2)-(state.rY+P_H/2))/(P_H/2);
        b.vy += rel*95; state.rally++;
      }
    }

    // scoring
    if (b.x+BALL < 0){
      state.scoreR++; state.rally=0; spawnBall(+1); state.counting=true; state.t0=performance.now();
      checkWin();
    } else if (b.x > state.cssW){
      state.scoreL++; state.rally=0; spawnBall(-1); state.counting=true; state.t0=performance.now();
      checkWin();
    }
  }

  function step(dt){
    if (state.gameover || state.paused) return;
    if (state.counting) return;

    // player input
    if (keys.up)   state.lY -= SPEED_PADDLE*dt;
    if (keys.down) state.lY += SPEED_PADDLE*dt;

    if (pointerY != null){
      const rect = canvas.getBoundingClientRect();
      const y = (pointerY - rect.top) * (state.cssH/rect.height) - P_H/2;
      const dy = clamp(y,0,state.cssH-P_H) - state.lY;
      state.lY += clamp(dy, -SPEED_PADDLE*dt, SPEED_PADDLE*dt);
    }
    state.lY = clamp(state.lY, 0, state.cssH-P_H);

    // AI
    const b = state.balls[0];
    const target = b.y + BALL/2 - P_H/2 + Math.sin(performance.now()/250)*6;
    const dy = target - state.rY;
    state.rY = clamp(state.rY + clamp(dy, -SPEED_AI*dt, SPEED_AI*dt), 0, state.cssH-P_H);

    // advance ball(s)
    for (const ball of state.balls) stepBall(ball, dt);
  }

  function checkWin(){
    if (state.scoreL >= WIN_SCORE || state.scoreR >= WIN_SCORE){
      state.gameover = true;
      showOverlay('Game Over', `Final ${state.scoreL} ‚Äì ${state.scoreR}`);
      // high score save
      const hs = Number(localStorage.getItem('retro_high')||0);
      if (state.scoreL > hs) localStorage.setItem('retro_high', String(state.scoreL));
    }
  }

  /* ===== Draw (Retro CRT) ===== */
  function drawCRT(w,h){
    // background grid glow
    ctx.fillStyle = '#0d1315';
    ctx.fillRect(0,0,w,h);

    // dotted midline
    ctx.fillStyle = 'rgba(180,255,200,.75)';
    const mid = (w/2|0)-1;
    for (let y=10; y<h-10; y+=DOT_H+DOT_G) ctx.fillRect(mid, y, 2, DOT_H);

    // thin inner border glow
    ctx.strokeStyle = 'rgba(160,255,195,.22)';
    ctx.lineWidth = 1;
    ctx.strokeRect(8.5,8.5,w-17,h-17);
  }

  function drawPaddle(x,y,w,h){
    ctx.save();
    ctx.shadowColor='rgba(160,255,195,.35)'; ctx.shadowBlur=12;
    ctx.fillStyle = '#caffb9';
    roundedRect(x,y,w,h,P_R); ctx.fill();
    ctx.restore();

    // face lines
    ctx.strokeStyle='rgba(0,30,0,0.25)'; ctx.lineWidth=1;
    ctx.beginPath();
    for(let yy=y+6; yy<y+h-6; yy+=6){ ctx.moveTo(x+3,yy); ctx.lineTo(x+w-3,yy); }
    ctx.stroke();
  }

  function drawBall(x,y){
    const cx=x+BALL/2, cy=y+BALL/2;
    // glow
    const g=ctx.createRadialGradient(cx,cy,0,cx,cy,10);
    g.addColorStop(0,'rgba(255,238,170,1)');
    g.addColorStop(1,'rgba(255,238,170,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.fill();
    // core
    ctx.fillStyle = '#ffde8a';
    ctx.fillRect(x,y,BALL,BALL);
  }

  function draw(){
    const w=state.cssW, h=state.cssH;
    drawCRT(w,h);

    // paddles
    drawPaddle(12, state.lY, P_W, P_H);
    drawPaddle(w - P_W - 12, state.rY, P_W, P_H);

    // balls
    for (const b of state.balls) drawBall(b.x,b.y);

    // countdown
    if (state.counting){
      const el=(performance.now()-state.t0)/1000;
      const rem=Math.max(0,3-Math.floor(el));
      if (rem>0){
        ctx.font = '900 72px ui-monospace, monospace';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillStyle = '#ffdd7a'; ctx.globalAlpha=.95;
        const frac = 1-(el%1), s = 1+0.18*(1-frac);
        ctx.save(); ctx.translate(w/2,h/2); ctx.scale(s,s); ctx.fillText(String(rem),0,0); ctx.restore();
        ctx.globalAlpha=1;
      } else state.counting=false;
    }

    // update DOM HUD
    scL.textContent = String(state.scoreL);
    scR.textContent = String(state.scoreR);
    hud.textContent = state.gameover ? 'Game Over' : (state.paused ? 'Paused' : `Rally: ${state.rally}`);

    // tell Farcaster host we‚Äôre ready after first paint
    signalReadyOnce();
  }

  /* ===== Loop ===== */
  function loop(ts){
    if (!state.last) state.last=ts;
    let dt=(ts-state.last)/1000; state.last=ts;

    if (!state.paused && !state.gameover){
      state.accum=Math.min(MAX_ACCUM, state.accum+dt);
      while(state.accum>=FIXED_DT){
        step(FIXED_DT);
        state.accum-=FIXED_DT;
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  /* ===== Overlay & buttons ===== */
  function showOverlay(title, sub){
    ovTitle.textContent = title;
    ovSub.textContent = sub || 'First to 11 ‚Ä¢ Arrow keys / drag to move';
    overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false');
    playBtn.style.display = state.gameover ? 'none' : 'inline-block';
    againBtn.style.display = state.gameover ? 'inline-block' : 'none';
  }
  function hideOverlay(){
    overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true');
  }

  playBtn.onclick = ()=>{ state.paused=false; state.counting=true; state.t0=performance.now(); hideOverlay(); };
  againBtn.onclick= ()=>{
    state.scoreL=0; state.scoreR=0; state.rally=0; state.gameover=false;
    resetPositions(); state.paused=false; state.counting=true; state.t0=performance.now();
    hideOverlay();
  };
  pauseBtn.onclick= ()=>{
    if (state.gameover) return;
    state.paused = !state.paused;
    if (state.paused) showOverlay('Paused'); else hideOverlay();
  };
  closeBtn.onclick= ()=>{ showOverlay('RETROPONG'); };

  addBtn.onclick = async ()=>{
    if(fc){ try{ await fc.actions.addMiniApp(); return; }catch(e){} }
    // fallback: open your URL (replace with your real domain)
    window.open('https://your-domain.com/','_blank');
  };

  shareBtn.onclick = async ()=>{
    const hs = Number(localStorage.getItem('retro_high')||0);
    const text = `I just hit ${hs} in RETROPONG! üëæ https://your-domain.com/`;
    if(fc){ try{ await fc.actions.composeCast({ text }); return; }catch(e){} }
    if(navigator.share){ try{ await navigator.share({ text }); return; }catch(e){} }
    try{ await navigator.clipboard.writeText(text); shareBtn.textContent='‚úÖ Copied!'; setTimeout(()=>shareBtn.textContent='üì£ Share High Score',1400);}catch(_){}
  };

  /* ===== Input ===== */
  function onKey(e){ const d = e.type==='keydown';
    if (e.key==='ArrowUp'   || e.key==='w' || e.key==='W'){ keys.up=d;   e.preventDefault(); }
    if (e.key==='ArrowDown' || e.key==='s' || e.key==='S'){ keys.down=d; e.preventDefault(); }
    if (e.key==='Escape'){ pauseBtn.click(); }
    if (e.key==='Enter' && overlay.classList.contains('show')){ (state.gameover?againBtn:playBtn).click(); }
  }
  window.addEventListener('keydown',onKey,{passive:false});
  window.addEventListener('keyup',onKey,{passive:false});

  let pointerY=null;
  canvas.addEventListener('pointerdown', e=>{ pointerY=e.clientY; },{passive:true});
  window.addEventListener('pointermove', e=>{ if(pointerY!=null) pointerY=e.clientY; },{passive:true});
  window.addEventListener('pointerup', ()=>{ pointerY=null; },{passive:true});

  window.addEventListener('resize', sizeCanvas, {passive:true});
  document.addEventListener('visibilitychange', ()=>{ state.last=0; });

  /* ===== Boot ===== */
  function init(){
    sizeCanvas();
    resetPositions();
    // show menu on load
    state.paused = true; state.gameover=false; showOverlay('RETROPONG');
    requestAnimationFrame(loop);
  }
  init();
})();
</script>
</body>
</html>
