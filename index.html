<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Pong • Pickleball Theme</title>

  <!-- Farcaster Mini App embed -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://VishalGoswamii.github.io/pong-miniapp/assets/og.png",
    "button":{"title":"Play Pong","action":{ 
      "type":"launch_frame","name":"Pong",
      "url":"https://VishalGoswamii.github.io/pong-miniapp/",
      "splashImageUrl":"https://VishalGoswamii.github.io/pong-miniapp/assets/icon-200.png",
      "splashBackgroundColor":"#0f172a"
    }}
  }' />

  <style>
    :root{
      --courtOuter:#061429;
      --courtMain:#1E40AF;
      --courtKitchen:#ef4444;
      --courtLine:#F8FAFC;
      --centerRed:#ef4444;
      --ballY:#FDE047;
      --paddleFace:#D4DEE9;
      --paddleEdge:#425C7A;
    }

    html, body { margin:0; height:100%; background:var(--courtOuter); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }

    #wrap { position:fixed; inset:0; z-index:0; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    #score { position:fixed; top:calc(env(safe-area-inset-top) + 10px); left:50%; transform:translateX(-50%);
      color:#fff; font-weight:1000; letter-spacing:1.2px; font-size:28px; padding:8px 14px; border-radius:16px;
      background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.07));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16), 0 14px 40px rgba(0,0,0,0.45);
    }
    #score.bump { animation: bump .18s ease; }
    @keyframes bump { 50% { transform: translateX(-50%) scale(1.08);} }

    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:2; }
    #overlay.hidden { display:none; }
    .card { background: rgba(12,18,32,0.86);
      border:1px solid rgba(255,255,255,0.14); color:#e9f1ff; padding:26px 22px; border-radius:18px; text-align:center;
      box-shadow: 0 28px 90px rgba(0,0,0,0.55); max-width:560px; margin:24px; }
    .title { margin:6px 0 2px; font-size:32px; font-weight:1000; color:#fff; }
    .brand { margin-top:0; font-size:14px; letter-spacing:0.6px; opacity:0.9; }
    .sub { margin-top:8px; opacity:0.85; }
    .actions { margin-top:14px; display:flex; justify-content:center; gap:12px; }
    .card button, .card select { padding:12px 16px; border-radius:14px; border:1px solid rgba(255,255,255,0.18); font-weight:900; font-size:15px; cursor:pointer; }
    .card button { color:#08111a; background:#60A5FA; box-shadow: 0 8px 24px rgba(37,99,235,.45), inset 0 0 0 1px rgba(255,255,255,0.18); }
    .card select { background:#0f172a; color:#e9f1ff; }

    #hint { position:fixed; bottom:calc(env(safe-area-inset-bottom) + 10px); left:0; right:0; text-align:center; color:#e7f2ff; font-size:13px; opacity:.9; }
  </style>
</head>
  <!-- Tell Farcaster we're ready (hide the splash) -->
<script>
(function () {
  // call ready() if an SDK is already injected
  function tryReadyFromGlobal() {
    try {
      if (window.__fc_sdk && window.__fc_sdk.actions && typeof window.__fc_sdk.actions.ready === 'function') {
        window.__fc_sdk.actions.ready();
        return true;
      }
    } catch (e) {}
    return false;
  }

  // attempt to import the SDK and then call ready()
  async function importAndReady() {
    try {
      const mod = await import('https://esm.sh/@farcaster/miniapp-sdk');
      const sdk = mod.sdk || mod;
      window.__fc_sdk = sdk;
      if (sdk && sdk.actions && typeof sdk.actions.ready === 'function') {
        sdk.actions.ready();
      }
    } catch (e) {
      // outside Farcaster or import blocked — ignore
    }
  }

  // run as soon as DOM is usable
  if (!tryReadyFromGlobal()) {
    importAndReady();
    // backup: try again shortly in case SDK injects late
    setTimeout(tryReadyFromGlobal, 1200);
  }
})();
</script>

<body>
  <div id="wrap"><canvas id="game" aria-label="Pong"></canvas></div>
  <div id="score" aria-live="polite">0 : 0</div>
  <div id="overlay">
    <div class="card home">
      <h1 class="title">PONG</h1>
      <div class="brand">Pickleball Theme</div>
      <p class="sub">Classic Pong • Drag to move • Beat the AI</p>
      <div class="actions">
        <label class="brand" style="display:flex;align-items:center;gap:8px;">
          Speed
          <select id="speedMode">
            <option value="slow" selected>Slow</option>
            <option value="normal">Normal</option>
            <option value="fast">Fast</option>
          </select>
        </label>
        <button id="play" onclick="window.startGame && window.startGame()">Play</button>
      </div>
    </div>
  </div>
  <div id="hint">Blue court, red kitchen. Pure Pong.</div>

  <script>
  'use strict';
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');

  function bindUI(){
    const playBtn = document.getElementById('play');
    if (playBtn) playBtn.addEventListener('click', start, { passive:true });
  }
  if (document.readyState !== 'loading') bindUI(); else document.addEventListener('DOMContentLoaded', bindUI);

  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=0, H=0, last=0, running=false, paused=false, noScoreUntil=0;

  const paddle = { w: 4*dpr, h: 70*dpr };
  let playerY=0, aiY=0;
  const ball = { x:0, y:0, r:9, vx:0, vy:0, baseSpeed:380 };
  let speedMul = 0.75; // default slow

  let scoreL=0, scoreR=0;
  let aiSpeed = 300 * dpr;
  const aiNoise = 26 * dpr;

  function resize(){
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    W = canvas.width; H = canvas.height;
    paddle.h = Math.max(56*dpr, Math.min(H*0.16, 86*dpr)) * 0.90;
    if (!running && last===0){ playerY = H/2; aiY = H/2; ball.x = W/2; ball.y = H/2; }
    noScoreUntil = performance.now() + 250;
    draw();
  }
  addEventListener('resize', resize);

  const clamp = (v,min,max) => v<min?min:v>max?max:v;
  const css = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

  function resetBall(dir=1){
    ball.x = W/2; ball.y = H/2;
    const angle = (Math.random()*0.5 - 0.25);
    const sp = ball.baseSpeed * speedMul * dpr;
    ball.vx = Math.cos(angle) * sp * dir;
    ball.vy = Math.sin(angle) * sp;
    playerY = H/2; aiY = H/2;
    noScoreUntil = performance.now() + 200;
  }

  function updateFromPointer(e){
    const r = canvas.getBoundingClientRect();
    const y = (e.clientY - r.top) * dpr;
    playerY = clamp(y, paddle.h/2, H - paddle.h/2);
    e.preventDefault();
  }
  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ dragging=true; if(!running) start(); updateFromPointer(e); }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{ if(!dragging) return; updateFromPointer(e); }, {passive:false});
  canvas.addEventListener('pointerup', ()=> dragging=false, {passive:true});
  canvas.addEventListener('pointercancel', ()=> dragging=false, {passive:true});

  function drawCourt(){
    ctx.fillStyle = css('--courtOuter'); ctx.fillRect(0,0,W,H);
    ctx.fillStyle = css('--courtMain'); ctx.fillRect(0,0,W,H);
    const kW = W * (7/44);
    ctx.fillStyle = css('--courtKitchen');
    ctx.fillRect(W/2 - kW, 0, kW, H);
    ctx.fillRect(W/2, 0, kW, H);
    ctx.save();
    ctx.strokeStyle = css('--courtLine');
    ctx.lineWidth = 3*dpr; ctx.lineCap='square';
    ctx.strokeRect(1.5*dpr, 1.5*dpr, W-3*dpr, H-3*dpr);
    ctx.setLineDash([10*dpr, 14*dpr]);
    ctx.strokeStyle = css('--centerRed'); ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
    ctx.setLineDash([]); ctx.strokeStyle = css('--courtLine');
    ctx.beginPath(); ctx.moveTo(W/2 - kW, 0); ctx.lineTo(W/2 - kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W/2 + kW, 0); ctx.lineTo(W/2 + kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
    ctx.restore();
  }

  function drawPaddle(x,y,w,h){
    ctx.fillStyle = css('--paddleFace');
    const r = Math.min(6*dpr, w);
    ctx.beginPath();
    ctx.moveTo(x, y-h/2+r);
    ctx.arcTo(x, y-h/2, x+w, y-h/2, r);
    ctx.arcTo(x+w, y-h/2, x+w, y+h/2, r);
    ctx.arcTo(x+w, y+h/2, x, y+h/2, r);
    ctx.arcTo(x, y+h/2, x, y-h/2, r);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = 1*dpr; ctx.strokeStyle = css('--paddleEdge'); ctx.stroke();
  }

  function drawBall(){
    const rr = ball.r*dpr;
    ctx.fillStyle = css('--ballY');
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth = 1.2*dpr; ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.stroke();
  }

  function draw(){
    drawCourt();
    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    drawPaddle(px, playerY, paddle.w, paddle.h);
    drawPaddle(ax, aiY,     paddle.w, paddle.h);
    drawBall();
  }

  function step(dt){
    const oldX = ball.x;
    const r = ball.r * dpr;
    ball.x += ball.vx * dt; ball.y += ball.vy * dt;

    if (ball.y < r) { ball.y = r; ball.vy *= -1; }
    if (ball.y > H - r) { ball.y = H - r; ball.vy *= -1; }

    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    const pTop = playerY - paddle.h/2, pBot = playerY + paddle.h/2;
    const aTop = aiY - paddle.h/2, aBot = aiY + paddle.h/2;

    if (ball.vx < 0) {
      if (ball.x - r <= px + paddle.w && ball.x - r >= px && ball.y >= pTop && ball.y <= pBot) {
        ball.x = px + paddle.w + r;
        const t = (ball.y - playerY) / (paddle.h/2);
        ball.vx = Math.abs(ball.vx) * 1.01;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }
      }
    } else {
      if (ball.x + r >= ax && ball.x + r <= ax + paddle.w && ball.y >= aTop && ball.y <= aBot) {
        ball.x = ax - r;
        const t = (ball.y - aiY) / (paddle.h/2);
        ball.vx = -Math.abs(ball.vx) * 1.02;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }
      }
    }

    if (performance.now() >= noScoreUntil) {
      const leftCross  = (ball.vx < 0) && ((oldX + r) >= 0) && ((ball.x + r) < 0);
      const rightCross = (ball.vx > 0) && ((oldX - r) <= W) && ((ball.x - r) > W);
      if (leftCross) { score('R'); return; }
      if (rightCross) { score('L'); return; }
    }

    const target = clamp(ball.y + (Math.random()*2-1)*aiNoise, paddle.h/2, H - paddle.h/2);
    const dy = target - aiY; const maxStep = aiSpeed * dt; aiY += clamp(dy, -maxStep, maxStep);

    playerY = clamp(playerY, paddle.h/2, H - paddle.h/2);
    aiY = clamp(aiY, paddle.h/2, H - paddle.h/2);

    draw();
  }

  function score(side){
    if (side === 'L') scoreL++; else scoreR++;
    scoreEl.textContent = scoreL + " : " + scoreR;
    scoreEl.classList.remove('bump'); void scoreEl.offsetWidth; scoreEl.classList.add('bump');
    resetBall(side === 'L' ? -1 : 1);
  }

  function loop(ts){
    const dt = Math.min(0.02, ((last===0? ts-16 : ts) - last)/1000 || 0.016);
    last = ts;
    if (!paused) step(dt);
    if (running) requestAnimationFrame(loop);
  }

  function start(){
    const sel = document.getElementById('speedMode');
    const v = sel ? sel.value : 'slow';
    speedMul = (v==='fast') ? 1.25 : (v==='normal') ? 1.0 : 0.75;
    aiSpeed = (v==='fast') ? 360*dpr : (v==='normal') ? 330*dpr : 300*dpr;

    scoreL=0; scoreR=0; scoreEl.textContent = "0 : 0";
    playerY = H/2; aiY = H/2;
    resetBall(Math.random()<0.5? -1 : 1);
    overlay.classList.add('hidden');
    paused=false; running=true; last=0;
    requestAnimationFrame(loop);
  }
  window.startGame = start;

  resize(); draw();
  </script>
</body>
</html>
