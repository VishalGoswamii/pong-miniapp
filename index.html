<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Neon Pong â€” Mini App</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

  <!-- Farcaster Mini App meta (safe if ignored elsewhere) -->
  <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://your-domain.com/og-1200x800.png","button":{"title":"Play","action":{"type":"launch_frame","name":"Neon Pong","url":"https://your-domain.com"}}}'/>

  <style>
    :root{
      --bg:#0b0b14;         /* deep space */
      --mid:#141b2c;        /* dotted midline color */
      --white:#ffffff;      /* paddles & scores */
      --orange:#ff9b0d;     /* ball core + combo text */
      --orange-soft: rgba(255,155,13,.7);
      --purple:#7a2dff;     /* magenta/purple trail tint */
    }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--white);}
    .wrap{position:fixed;inset:0;display:grid;place-items:center;contain:strict}
    canvas{width:min(100vw,100vh*(1));height:min(100vh,100vw*(1));display:block;background:var(--bg)}
    .hud{position:fixed;inset:8px 0 auto 0;text-align:center;font:700 28px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;pointer-events:none;color:#fff;letter-spacing:.5px}
    .combo{position:fixed;right:20px;bottom:18px;text-align:right;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;pointer-events:none}
    .combo .label{font-weight:800;font-size:20px;color:var(--orange);opacity:.95}
    .combo .value{font-weight:900;font-size:56px;color:var(--orange)}
  </style>
</head>
<body>
  <div class="wrap"><canvas id="game" aria-label="Neon Pong"></canvas></div>
  <div class="hud" id="scores"></div>
  <div class="combo" id="combo"><div class="label">COMBO</div><div class="value">0</div></div>

<script>
(function(){
  'use strict';

  // ---------- Canvas + sizing ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d',{alpha:false,desynchronized:true});
  const scoresEl = document.getElementById('scores');
  const comboEl = document.getElementById('combo').querySelector('.value');

  const DPR_MIN=1, DPR_MAX=2, FIXED_DT=1/60, MAX_ACCUM=0.25;

  function clamp(v,a,b){return v<a?a:v>b?b:v;}
  function sizeCanvas(){
    const r=canvas.getBoundingClientRect();
    const dpr=clamp(window.devicePixelRatio||1,DPR_MIN,DPR_MAX);
    if (state.cssW===r.width && state.cssH===r.height && state.dpr===dpr) return;
    state.cssW=r.width|0; state.cssH=r.height|0; state.dpr=dpr;
    canvas.width = Math.max(1,Math.floor(state.cssW*dpr));
    canvas.height= Math.max(1,Math.floor(state.cssH*dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled=false;
  }

  // ---------- Look constants to match image ----------
  const PADDLE_W = 14;            // a bit thicker
  const PADDLE_H = 112;           // taller to match feel
  const PADDLE_RADIUS = 7;        // rounded ends
  const BALL = 10;                // square sprite size (we draw glow around it)
  const DOT_W = 3, DOT_H = 9, DOT_GAP = 9; // midline
  const SCORE_FONT = '900 64px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';

  // Physics
  const SPEED_BALL = 240;
  const SPEED_AI   = 310;
  const SPEED_PADDLE = 380;

  // State
  const state = {
    dpr:1, cssW:0, cssH:0,
    last:0, accum:0, running:true,
    lY:0, rY:0,
    balls:[],                // support multiball if you add later
    rally:0, scoreL:0, scoreR:0,
    counting:true, t0:0,
    // spark particles on hits
    sparks:[]
  };

  // ---------- Helpers ----------
  function reset(){
    state.lY=(state.cssH-PADDLE_H)/2;
    state.rY=(state.cssH-PADDLE_H)/2;
    state.balls=[spawnBall(Math.random()<0.5?-1:1)];
    state.rally=0;
    state.counting=true; state.t0=performance.now();
  }
  function spawnBall(dir){
    const ay = clamp(Math.random()*2-1,-0.72,0.72);
    const s = SPEED_BALL*(1+Math.min(0.012*state.rally, 0.6)); // slight ramp
    const vx = dir*s*Math.sqrt(1-ay*ay);
    const vy = s*ay;
    return {x:(state.cssW-BALL)/2,y:(state.cssH-BALL)/2,vx,vy};
  }
  function roundedRect(x,y,w,h,r){
    const rr=Math.min(r,Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // Sparks for paddle impact (tiny glowing dots)
  function addSparks(x,y,color){
    for(let i=0;i<18;i++){
      const a=Math.random()*Math.PI*2;
      const sp=40+Math.random()*80;
      state.sparks.push({
        x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp,
        life:0.35, t:0, color
      });
    }
  }

  // ---------- Simulation ----------
  const keys={up:false,down:false}; let pointerY=null;

  function step(dt){
    if (state.counting) return;

    // Player paddle (keyboard + pointer blend)
    if (keys.up)   state.lY -= SPEED_PADDLE*dt;
    if (keys.down) state.lY += SPEED_PADDLE*dt;
    if (pointerY!=null){
      const rect=canvas.getBoundingClientRect();
      const y=(pointerY-rect.top)*(state.cssH/rect.height) - PADDLE_H/2;
      const dy = clamp(y,0,state.cssH-PADDLE_H)-state.lY;
      const max=SPEED_PADDLE*dt;
      state.lY += clamp(dy,-max,max);
    }
    state.lY = clamp(state.lY,0,state.cssH-PADDLE_H);

    // AI paddle follows ball's y (slightly imperfect)
    const b = state.balls[0];
    const target = b.y + BALL/2 - PADDLE_H/2;
    const dy = target - state.rY;
    const stepY = clamp(dy, -SPEED_AI*dt, SPEED_AI*dt);
    state.rY = clamp(state.rY + stepY, 0, state.cssH-PADDLE_H);

    // Balls
    for (const ball of state.balls){
      ball.x += ball.vx*dt; ball.y += ball.vy*dt;

      // top/bottom
      if (ball.y<=0){ ball.y=0; ball.vy=Math.abs(ball.vy); }
      else if (ball.y+BALL>=state.cssH){ ball.y=state.cssH-BALL; ball.vy=-Math.abs(ball.vy); }

      // left paddle
      if (ball.x <= PADDLE_W+12){
        if (ball.y+BALL>=state.lY && ball.y<=state.lY+PADDLE_H){
          ball.x=PADDLE_W+12;
          const before=ball.vx;
          ball.vx = Math.abs(ball.vx)*1.04;
          const rel=((ball.y+BALL/2)-(state.lY+PADDLE_H/2))/(PADDLE_H/2);
          ball.vy += rel*95;
          state.rally++;
          addSparks(PADDLE_W+12, ball.y+BALL/2, 'rgba(255,155,13,.9)');
        }
      }
      // right paddle
      const rx = state.cssW-(PADDLE_W+12)-BALL;
      if (ball.x >= rx){
        if (ball.y+BALL>=state.rY && ball.y<=state.rY+PADDLE_H){
          ball.x=rx;
          ball.vx = -Math.abs(ball.vx)*1.04;
          const rel=((ball.y+BALL/2)-(state.rY+PADDLE_H/2))/(PADDLE_H/2);
          ball.vy += rel*95;
          state.rally++;
          addSparks(rx+BALL, ball.y+BALL/2, 'rgba(255,155,13,.9)');
        }
      }

      // score
      if (ball.x+BALL<0){
        state.scoreR++; state.rally=0;
        state.balls=[spawnBall(+1)];
        state.counting=true; state.t0=performance.now();
      } else if (ball.x>state.cssW){
        state.scoreL++; state.rally=0;
        state.balls=[spawnBall(-1)];
        state.counting=true; state.t0=performance.now();
      }
    }

    // sparks
    for (let i=state.sparks.length-1;i>=0;i--){
      const p=state.sparks[i]; p.t+=dt;
      p.x+=p.vx*dt; p.y+=p.vy*dt;
