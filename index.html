<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Pong • Pickleball Theme</title>

  <!-- Farcaster Mini App embed (Vercel domain + root images) -->
  <meta name="fc:miniapp" content='{
    "version": "1",
    "imageUrl": "https://pong-miniapp.vercel.app/og.png",
    "button": {
      "title": "Play Pong",
      "action": {
        "type": "launch_frame",
        "name": "Pong",
        "url": "https://pong-miniapp.vercel.app/",
        "splashImageUrl": "https://pong-miniapp.vercel.app/icon-200.png",
        "splashBackgroundColor": "#0f172a"
      }
    }
  }' />

  <!-- PeerJS for online 1v1 (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.5/peerjs.min.js" defer></script>

  <style>
    :root{
      --courtOuter:#061429;
      --courtMain:#1E40AF;
      --courtKitchen:#ef4444;
      --courtLine:#F8FAFC;
      --centerRed:#ef4444;
      --ballY:#FDE047;
      --paddleFace:#D4DEE9;
      --paddleEdge:#425C7A;
    }

    html, body { margin:0; height:100%; background:var(--courtOuter); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #wrap { position:fixed; inset:0; z-index:0; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    #score { position:fixed; top:calc(env(safe-area-inset-top) + 10px); left:50%; transform:translateX(-50%);
      color:#fff; font-weight:1000; letter-spacing:1.2px; font-size:28px; padding:8px 14px; border-radius:16px;
      background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.07));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16), 0 14px 40px rgba(0,0,0,0.45);
    }
    #score.bump { animation: bump .18s ease; }
    @keyframes bump { 50% { transform: translateX(-50%) scale(1.08);} }

    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:2; }
    #overlay.hidden { display:none; }
    .card { background: rgba(12,18,32,0.86);
      border:1px solid rgba(255,255,255,0.14); color:#e9f1ff; padding:26px 22px; border-radius:18px; text-align:center;
      box-shadow: 0 28px 90px rgba(0,0,0,0.55); max-width:620px; margin:24px; }
    .title { margin:6px 0 2px; font-size:32px; font-weight:1000; color:#fff; }
    .sub { margin-top:8px; opacity:0.85; }

    .mode-grid { display:grid; grid-template-columns:1fr; gap:14px; margin-top:14px; }
    .mode { display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px; border:1px solid rgba(255,255,255,0.18); border-radius:14px; background:rgba(255,255,255,0.05); }
    .mode h3 { margin:0; font-size:18px; }
    .mode p  { margin:0; font-size:13px; opacity:.9; }

    .row { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px; }
    .row input { padding:12px 14px; border-radius:12px; border:1px solid rgba(255,255,255,0.18); background:#0b1424; color:#e9f1ff; width:160px; text-align:center; }
    button { padding:12px 16px; border-radius:14px; border:1px solid rgba(255,255,255,0.18); font-weight:900; font-size:15px; cursor:pointer; }
    .primary { color:#08111a; background:#60A5FA; box-shadow: 0 8px 24px rgba(37,99,235,.45), inset 0 0 0 1px rgba(255,255,255,0.18); }
    .ghost   { color:#e9f1ff; background:transparent; }

    #hint { position:fixed; bottom:calc(env(safe-area-inset-bottom) + 10px); left:0; right:0; text-align:center; color:#e7f2ff; font-size:13px; opacity:.9; }

    /* player badges */
    #players { position:fixed; top:calc(env(safe-area-inset-top) + 54px); left:0; right:0; display:flex; justify-content:space-between; padding:0 10px; pointer-events:none; }
    .pb { display:flex; align-items:center; gap:8px; background:rgba(12,18,32,.6); border:1px solid rgba(255,255,255,.14);
      color:#eaf3ff; padding:6px 10px; border-radius:999px; min-width:120px; }
    .pb img { width:24px; height:24px; border-radius:999px; object-fit:cover; background:#0f172a; }
    .pb .name { font-weight:800; font-size:13px; }
    .pb .tag  { font-size:12px; opacity:.8; }

    /* tiny toasts */
    #toast { position:fixed; top:calc(env(safe-area-inset-top) + 10px); right:10px; color:#fff; background:rgba(0,0,0,.6); padding:8px 10px; border-radius:10px; font-size:12px; display:none; }
    #toast.show { display:block; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Pong"></canvas></div>
  <div id="score" aria-live="polite">0 : 0</div>

  <div id="players">
    <div class="pb" id="p1"><img id="p1img" alt=""><div><div class="name" id="p1name">You</div><div class="tag">P1</div></div></div>
    <div class="pb" id="p2"><img id="p2img" alt=""><div><div class="name" id="p2name">CPU</div><div class="tag" id="p2tag">AI</div></div></div>
  </div>

  <div id="overlay">
    <div class="card home">
      <h1 class="title">PONG</h1>
      <p class="sub">Pickleball blue court • red kitchen • beat your opponent</p>

      <div class="mode-grid">
        <div class="mode">
          <div>
            <h3>Single Player (vs AI)</h3>
            <p>Fast, fair AI. Drag anywhere to move.</p>
          </div>
          <button class="primary" id="btnSingle">Play</button>
        </div>

        <div class="mode">
          <div>
            <h3>Online 1v1 (Farcaster)</h3>
            <p>Create a room and share the code, or join a friend’s room.</p>
            <div class="row">
              <button class="primary" id="btnCreate">Create Room</button>
              <input id="roomCode" placeholder="Enter code" />
              <button class="ghost" id="btnJoin">Join</button>
            </div>
            <div class="row" id="shareRow" style="display:none;">
              <input id="shareLink" readonly />
              <button class="primary" id="copyLink">Copy</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div id="hint">Swipe/drag to move. Online mode requires both players to open the app.</div>
  <div id="toast"></div>

  <script>
  'use strict';
  /*********** DOM ***********/
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const p1img = document.getElementById('p1img'), p1name = document.getElementById('p1name');
  const p2img = document.getElementById('p2img'), p2name = document.getElementById('p2name'), p2tag = document.getElementById('p2tag');
  const toast = document.getElementById('toast');

  const btnSingle = document.getElementById('btnSingle');
  const btnCreate = document.getElementById('btnCreate');
  const btnJoin   = document.getElementById('btnJoin');
  const roomCode  = document.getElementById('roomCode');
  const shareRow  = document.getElementById('shareRow');
  const shareLink = document.getElementById('shareLink');
  const copyLink  = document.getElementById('copyLink');

  function showToast(t){ toast.textContent = t; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 2500); }

  /*********** Farcaster user (username + pfp) ***********/
  // Pull from any known SDK global; if not inside Farcaster, returns null.
  function readMiniUser(){
    try {
      const c1 = window.__fc_sdk && window.__fc_sdk.context;
      const c2 = window.farcaster && window.farcaster.sdk && window.farcaster.sdk.context;
      const c3 = window.frame && window.frame.sdk && window.frame.sdk.context;
      const c4 = window.sdk && window.sdk.context;
      const cx = c1 || c2 || c3 || c4;
      if (cx && cx.user) return cx.user; // { fid, username, displayName, pfpUrl }
    } catch(e){}
    return null;
  }

  function setPlayerBadge(elImg, elName, obj, fallbackTag){
    if (obj) {
      elName.textContent = obj.displayName || obj.username || ('fid ' + obj.fid);
      if (obj.pfpUrl) { elImg.src = obj.pfpUrl; elImg.alt = elName.textContent; }
      else { elImg.removeAttribute('src'); elImg.alt = ''; }
    } else {
      elName.textContent = fallbackTag || 'Guest';
      elImg.removeAttribute('src'); elImg.alt = '';
    }
  }

  const me = readMiniUser(); // may be null outside Farcaster
  setPlayerBadge(p1img, p1name, me, 'You');

  /*********** Game state ***********/
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=0, H=0, last=0, running=false, paused=false, noScoreUntil=0;

  const paddle = { w: 4*dpr, h: 70*dpr };
  let playerY=0, oppY=0;
  const ball = { x:0, y:0, r:9, vx:0, vy:0, baseSpeed:380 };
  let speedMul = 1.0; // single speed (no Slow/Normal/Fast selector)

  let scoreL=0, scoreR=0;

  // AI
  let aiOn = true;
  let aiSpeed = 330 * dpr;
  const aiNoise = 26 * dpr;

  // Online (PeerJS)
  let MODE = 'home';          // 'single' | 'online-host' | 'online-guest'
  let peer = null, conn = null, isHost = false, netLastSend = 0;
  let oppUser = null;

  function resize(){
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    W = canvas.width; H = canvas.height;
    paddle.h = Math.max(56*dpr, Math.min(H*0.16, 86*dpr)) * 0.90;
    if (!running && last===0){ playerY = H/2; oppY = H/2; ball.x = W/2; ball.y = H/2; }
    noScoreUntil = performance.now() + 250;
    draw();
  }
  addEventListener('resize', resize);

  const clamp = (v,min,max) => v<min?min:v>max?max:v;
  const css = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

  function resetBall(dir=1){
    ball.x = W/2; ball.y = H/2;
    const angle = (Math.random()*0.5 - 0.25);
    const sp = ball.baseSpeed * speedMul * dpr;
    ball.vx = Math.cos(angle) * sp * dir;
    ball.vy = Math.sin(angle) * sp;
    playerY = H/2; oppY = H/2;
    noScoreUntil = performance.now() + 200;
  }

  // Input (pointer + touch)
  function updateFromPointerLike(clientY){
    const r = canvas.getBoundingClientRect();
    const y = (clientY - r.top) * dpr;
    playerY = clamp(y, paddle.h/2, H - paddle.h/2);
    if (MODE === 'online-guest' && conn && conn.open) {
      // guest sends input to host
      try { conn.send({ t:'in', y: playerY }); } catch(e){}
    }
  }
  function onPointer(e){ updateFromPointerLike(e.clientY); e.preventDefault(); }
  function onTouch(e){ if (!e.touches || !e.touches[0]) return; updateFromPointerLike(e.touches[0].clientY); e.preventDefault(); }

  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ dragging=true; if(!running) startSingleIfNeeded(); onPointer(e); }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{ if(!dragging) return; onPointer(e); }, {passive:false});
  canvas.addEventListener('pointerup', ()=> dragging=false, {passive:true});
  canvas.addEventListener('pointercancel', ()=> dragging=false, {passive:true});

  canvas.addEventListener('touchstart', (e)=>{ dragging=true; if(!running) startSingleIfNeeded(); onTouch(e); }, {passive:false});
  canvas.addEventListener('touchmove',  (e)=>{ if(!dragging) return; onTouch(e); }, {passive:false});
  canvas.addEventListener('touchend',   ()=> dragging=false, {passive:true});
  canvas.addEventListener('touchcancel',()=> dragging=false, {passive:true});

  function startSingleIfNeeded(){
    if (MODE === 'single' && !running) startGame();
  }

  /*********** Rendering ***********/
  function drawCourt(){
    ctx.fillStyle = css('--courtOuter'); ctx.fillRect(0,0,W,H);
    ctx.fillStyle = css('--courtMain'); ctx.fillRect(0,0,W,H);
    const kW = W * (7/44);
    ctx.fillStyle = css('--courtKitchen');
    ctx.fillRect(W/2 - kW, 0, kW, H);
    ctx.fillRect(W/2, 0, kW, H);
    ctx.save();
    ctx.strokeStyle = css('--courtLine');
    ctx.lineWidth = 3*dpr; ctx.lineCap='square';
    ctx.strokeRect(1.5*dpr, 1.5*dpr, W-3*dpr, H-3*dpr);
    ctx.setLineDash([10*dpr, 14*dpr]);
    ctx.strokeStyle = css('--centerRed'); ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
    ctx.setLineDash([]); ctx.strokeStyle = css('--courtLine');
    ctx.beginPath(); ctx.moveTo(W/2 - kW, 0); ctx.lineTo(W/2 - kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W/2 + kW, 0); ctx.lineTo(W/2 + kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
    ctx.restore();
  }

  function drawPaddle(x,y,w,h){
    ctx.fillStyle = css('--paddleFace');
    const r = Math.min(6*dpr, w);
    ctx.beginPath();
    ctx.moveTo(x, y-h/2+r);
    ctx.arcTo(x, y-h/2, x+w, y-h/2, r);
    ctx.arcTo(x+w, y-h/2, x+w, y+h/2, r);
    ctx.arcTo(x+w, y+h/2, x, y+h/2, r);
    ctx.arcTo(x, y+h/2, x, y-h/2, r);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = 1*dpr; ctx.strokeStyle = css('--paddleEdge'); ctx.stroke();
  }

  function drawBall(){
    const rr = ball.r*dpr;
    ctx.fillStyle = css('--ballY');
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth = 1.2*dpr; ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.stroke();
  }

  function draw(){
    drawCourt();
    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    drawPaddle(px, playerY, paddle.w, paddle.h);
    drawPaddle(ax, oppY,     paddle.w, paddle.h);
    drawBall();
  }

  /*********** Step (host or single) ***********/
  function stepHostOrSingle(dt){
    const oldX = ball.x;
    const r = ball.r * dpr;
    ball.x += ball.vx * dt; ball.y += ball.vy * dt;

    // walls
    if (ball.y < r) { ball.y = r; ball.vy *= -1; }
    if (ball.y > H - r) { ball.y = H - r; ball.vy *= -1; }

    // paddles
    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    const pTop = playerY - paddle.h/2, pBot = playerY + paddle.h/2;
    const aTop = oppY - paddle.h/2, aBot = oppY + paddle.h/2;

    if (ball.vx < 0) {
      if (ball.x - r <= px + paddle.w && ball.x - r >= px && ball.y >= pTop && ball.y <= pBot) {
        ball.x = px + paddle.w + r;
        const t = (ball.y - playerY) / (paddle.h/2);
        ball.vx = Math.abs(ball.vx) * 1.01;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }
      }
    } else {
      if (ball.x + r >= ax && ball.x + r <= ax + paddle.w && ball.y >= aTop && ball.y <= aBot) {
        ball.x = ax - r;
        const t = (ball.y - oppY) / (paddle.h/2);
        ball.vx = -Math.abs(ball.vx) * 1.02;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }
      }
    }

    // scoring (after small grace)
    if (performance.now() >= noScoreUntil) {
      const leftCross  = (ball.vx < 0) && ((oldX + r) >= 0) && ((ball.x + r) < 0);
      const rightCross = (ball.vx > 0) && ((oldX - r) <= W) && ((ball.x - r) > W);
      if (leftCross) { score('R'); return; }
      if (rightCross){ score('L'); return; }
    }

    // AI move (only in single-player)
    if (aiOn) {
      const target = clamp(ball.y + (Math.random()*2-1)*aiNoise, paddle.h/2, H - paddle.h/2);
      const dy = target - oppY; const maxStep = aiSpeed * dt; oppY += clamp(dy, -maxStep, maxStep);
      oppY = clamp(oppY, paddle.h/2, H - paddle.h/2);
    }

    // clamp paddles
    playerY = clamp(playerY, paddle.h/2, H - paddle.h/2);

    draw();

    // send state to guest if online host
    if (MODE === 'online-host' && conn && conn.open) {
      const now = performance.now();
      if (now - netLastSend > 33) { // ~30fps
        netLastSend = now;
        try { conn.send({ t:'st', x:ball.x, y:ball.y, vx:ball.vx, vy:ball.vy, p1:playerY, p2:oppY, sl:scoreL, sr:scoreR, w:W, h:H }); } catch(e){}
      }
    }
  }

  function score(side){
    if (side === 'L') scoreL++; else scoreR++;
    scoreEl.textContent = scoreL + " : " + scoreR;
    scoreEl.classList.remove('bump'); void scoreEl.offsetWidth; scoreEl.classList.add('bump');
    resetBall(side === 'L' ? -1 : 1);
  }

  function loop(ts){
    const dt = Math.min(0.02, ((last===0? ts-16 : ts) - last)/1000 || 0.016);
    last = ts;
    if (!paused) {
      if (MODE === 'single' || MODE === 'online-host') stepHostOrSingle(dt);
      // online-guest: draw happens on incoming state, but still render last state to keep smooth
      if (MODE === 'online-guest') draw();
    }
    if (running) requestAnimationFrame(loop);
  }

  /*********** Start flows ***********/
  function startGame(){
    scoreL=0; scoreR=0; scoreEl.textContent = "0 : 0";
    playerY = H/2; oppY = H/2;
    resetBall(Math.random()<0.5? -1 : 1);
    overlay.classList.add('hidden');
    paused=false; running=true; last=0;
    requestAnimationFrame(loop);
  }

  function setBadgesForSingle(){
    setPlayerBadge(p1img, p1name, me, 'You');
    setPlayerBadge(p2img, p2name, { displayName:'CPU' }, 'CPU');
    p2tag.textContent = 'AI';
  }

  btnSingle.addEventListener('click', ()=>{
    MODE = 'single'; aiOn = true;
    setBadgesForSingle();
    startGame();
  });

  function makeCode(){ return Math.random().toString(36).slice(2,6).toUpperCase(); }

  btnCreate.addEventListener('click', ()=>{
    const code = makeCode();
    if (!window.Peer) { showToast('Loading network libs... try again in a sec'); return; }
    isHost = true; MODE = 'online-host'; aiOn = false;
    peer = new Peer('pong-' + code); // uses PeerJS cloud by default
    peer.on('open', id=>{
      shareRow.style.display = 'flex';
      const url = location.origin + location.pathname + '?join=' + code;
      shareLink.value = url;
      copyLink.onclick = ()=>{ navigator.clipboard.writeText(url); showToast('Link copied'); };
      // badges
      setPlayerBadge(p1img, p1name, me, 'You');
      setPlayerBadge(p2img, p2name, null, 'Waiting…'); p2tag.textContent = 'P2';
      overlay.classList.add('hidden');
      startGame();
    });
    peer.on('connection', c=>{
      conn = c;
      showToast('Player joined!');
      // send hello with my user
      const u = me || {};
      try { conn.send({ t:'hi', u: { fid:u.fid, username:u.username, displayName:u.displayName, pfpUrl:u.pfpUrl } }); } catch(e){}
      conn.on('data', onNetDataFromGuest);
      conn.on('close', ()=>{ showToast('Player left'); endOnline(); });
    });
    peer.on('error', err=>{ showToast('Net error'); console.warn(err); endOnline(); });
  });

  btnJoin.addEventListener('click', ()=>{
    const code = (roomCode.value || '').trim().toUpperCase();
    if (!code) { showToast('Enter a room code'); return; }
    if (!window.Peer) { showToast('Loading network libs... try again'); return; }
    isHost = false; MODE = 'online-guest'; aiOn = false;
    peer = new Peer(); // random id
    peer.on('open', ()=>{
      conn = peer.connect('pong-' + code);
      conn.on('open', ()=>{
        showToast('Connected!');
        // send hello with my user
        const u = me || {};
        try { conn.send({ t:'hi', u: { fid:u.fid, username:u.username, displayName:u.displayName, pfpUrl:u.pfpUrl } }); } catch(e){}
        overlay.classList.add('hidden');
        // guest waits for host state; render last received state continuously
        running=true; last=0; requestAnimationFrame(loop);
      });
      conn.on('data', onNetDataFromHost);
      conn.on('close', ()=>{ showToast('Disconnected'); endOnline(); });
    });
    peer.on('error', err=>{ showToast('Net error'); console.warn(err); endOnline(); });
  });

  function endOnline(){
    running=false; overlay.classList.remove('hidden');
    try { conn && conn.close(); } catch(e){}
    try { peer && peer.destroy(); } catch(e){}
    conn=null; peer=null; MODE='home'; shareRow.style.display='none';
  }

  // host receives guest input / hello
  function onNetDataFromGuest(msg){
    if (!msg || typeof msg !== 'object') return;
    if (msg.t === 'in') {
      oppY = clamp(msg.y, paddle.h/2, H - paddle.h/2);
    } else if (msg.t === 'hi') {
      oppUser = msg.u || null;
      setPlayerBadge(p2img, p2name, oppUser, 'Player 2'); p2tag.textContent = 'P2';
    }
  }
  // guest receives state / hello
  function onNetDataFromHost(msg){
    if (!msg || typeof msg !== 'object') return;
    if (msg.t === 'st') {
      // world state
      ball.x=msg.x; ball.y=msg.y; ball.vx=msg.vx; ball.vy=msg.vy;
      playerY=msg.p1; oppY=msg.p2; scoreL=msg.sl; scoreR=msg.sr;
      scoreEl.textContent = scoreL + " : " + scoreR;
      if (W!==msg.w || H!==msg.h) resize();
      draw();
    } else if (msg.t === 'hi') {
      oppUser = msg.u || null; // host user shown on left as P1
      setPlayerBadge(p1img, p1name, oppUser, 'P1');
      setPlayerBadge(p2img, p2name, me, 'You'); p2tag.textContent = 'P2';
    }
  }

  // Deep-link auto-join (?join=CODE)
  (function(){
    const m = /[?&]join=([A-Z0-9]{4})/i.exec(location.search);
    if (m) { roomCode.value = m[1].toUpperCase(); }
  })();

  /*********** Boot ***********/
  function drawOnce(){ draw(); }
  function init(){
    resize(); drawOnce();
  }
  init();

  // Start buttons also call sdk.actions.ready() via the global snippet below.

  </script>

  <!-- Farcaster: hide splash once ready (robust) -->
  <script>
  (function () {
    function callReadyFrom(obj){
      try{
        if (obj && obj.actions && typeof obj.actions.ready === 'function') {
          obj.actions.ready(); return true;
        }
      }catch(e){}
      return false;
    }
    function tryAll(){
      if (callReadyFrom(window.__fc_sdk)) return true;
      if (window.farcaster && tryAll.fromF(window.farcaster.sdk)) return true;
      if (window.frame && tryAll.fromF(window.frame.sdk)) return true;
      if (callReadyFrom(window.sdk)) return true;
      return false;
    }
    tryAll.fromF = callReadyFrom;

    if (!tryAll()) {
      requestAnimationFrame(function(){ requestAnimationFrame(tryAll); });
      var tries = 0, t = setInterval(function(){ if (tryAll() || ++tries > 60) clearInterval(t); }, 100);
    }
  })();
  </script>
</body>
</html>
