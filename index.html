<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>PicklePong Mini</title>

  <!-- Farcaster Frames + Mini App embed -->
  <meta property="fc:frame" content="vNext" />
  <meta property="fc:miniapp" content="vNext" />

  <!-- Open Graph -->
  <meta property="og:title" content="PicklePong Mini" />
  <meta property="og:description" content="Retro pickleball Pong made for Farcaster Mini Apps." />
  <meta property="og:image" content="https://pong-miniapp.vercel.app/og.png" />
  <meta property="og:url" content="https://pong-miniapp.vercel.app/" />

  <style>
    :root{
      --bg:#0a0e14;
      --court:#0fd976;
      --accent:#f5e04c;
      --text:#e6f1ff;
    }
    html,body{height:100%;margin:0;background:#070a10;color:var(--text);font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}

    /* Router visibility: each page defines its own layout */
    .view{display:none}
    .homeWrap.view.show, .gameWrap.view.show { display:flex }

    /* Shared buttons */
    .btn{border:1px solid rgba(245,224,76,.6);background:rgba(245,224,76,.08);color:var(--text);
         padding:.65rem 1rem;border-radius:1rem;font-weight:800;cursor:pointer;letter-spacing:.04em}
    .btn.primary{background:rgba(245,224,76,.25)}
    .btn.ghost{border-color:var(--court);}
    .btn.chip{padding:.45rem .7rem;border-radius:.8rem}

    /* Home page */
    .homeWrap{min-height:100vh;flex-direction:column}
    header.home{display:flex;align-items:center;justify-content:space-between;padding:1rem 1.1rem;
      background:linear-gradient(180deg,rgba(15,217,118,.08),rgba(15,217,118,.02));
      border-bottom:1px solid rgba(15,217,118,.25)}
    .brand{display:flex;align-items:center;gap:.65rem;font-weight:900;letter-spacing:.06em}
    .brand .dot{width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 0 18px var(--accent)}
    .homeMain{flex:1;display:grid;place-items:center;padding:18px}
    .homeCard{width:min(92vw,760px);border:1px solid rgba(15,217,118,.35);border-radius:22px;
      background:linear-gradient(180deg,rgba(15,217,118,.12),rgba(15,217,118,.04));
      box-shadow:0 18px 50px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.03);padding:22px}
    .logoHero{display:flex;flex-direction:column;align-items:center;gap:.6rem;padding:8px 0 10px}
    .logoBadge{display:flex;align-items:center;gap:.7rem;font-size:2rem;font-weight:1000;letter-spacing:.12em}
    .logoBadge .ball{width:20px;height:20px;border-radius:50%;background:var(--accent);box-shadow:0 0 18px var(--accent)}
    .modeRow{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:10px 0}
    .ctaRow{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:6px}
    .hint{color:#9fb7cd;text-align:center;margin-top:8px}

    /* Game page */
    .gameWrap{min-height:100vh;flex-direction:column}
    header.game{display:flex;align-items:center;justify-content:space-between;padding:.75rem 1rem;gap:.5rem;
      background:linear-gradient(180deg,rgba(15,217,118,.08),rgba(15,217,118,.02));
      border-bottom:1px solid rgba(15,217,118,.25)}
    .hud{display:flex;align-items:center;gap:.75rem;flex-wrap:wrap}

    .crt{position:relative;flex:1;display:grid;place-items:center;overflow:hidden}
    canvas{max-width:100vw;max-height:calc(100vh - 120px);width:min(92vw,820px);aspect-ratio:10/16;
      background:linear-gradient(180deg,rgba(15,217,118,.08),transparent 20%),
                 radial-gradient(400px 250px at 50% 0%, rgba(15,217,118,.18), transparent 55%), #0b0f15;
      border:1px solid rgba(15,217,118,.35);border-radius:22px;image-rendering:pixelated}

    .countdown{position:absolute;inset:0;display:none;place-items:center;backdrop-filter:blur(2px)}
    .countdown.show{display:grid}
    .countNum{font-weight:1000;font-size:4rem;letter-spacing:.06em;color:var(--accent);text-shadow:0 0 22px rgba(245,224,76,.45)}
  </style>

  <!-- Safe loader: try to import Mini App SDK, otherwise stub so preview still works -->
  <script>
    (async () => {
      try {
        const mod = await import('https://esm.sh/@farcaster/miniapp-sdk');
        window.farcasterSDK = mod.sdk;
      } catch (e) {
        window.farcasterSDK = { actions: { ready: async ()=>{}, share: async ()=>{} } }; // no-op in preview
      }
    })();
  </script>
</head>
<body>
  <!-- ================= HOME PAGE ================= -->
  <div id="homePage" class="homeWrap view show">
    <header class="home">
      <div class="brand"><span class="dot"></span> PicklePong <small style="opacity:.7;font-weight:600">Mini</small></div>
      <div class="row">
        <button id="btnAddFC" class="btn chip">‚≠ê Add to Farcaster</button>
      </div>
    </header>
    <main class="homeMain">
      <section class="homeCard">
        <div class="logoHero">
          <div class="logoBadge"><span class="ball"></span> PICKLEPONG</div>
          <div style="opacity:.8">Premium Retro ‚Ä¢ Mobile First ‚Ä¢ Mini App</div>
        </div>
        <div class="modeRow">
          <button id="playRegular" class="btn primary">‚ñ∂Ô∏è Play ‚Äî Regular (Slower)</button>
          <button id="playArcade"  class="btn ghost">‚ö° Play ‚Äî Arcade (Power-ups)</button>
        </div>
        <p class="hint">Drag anywhere to move your paddle ¬∑ Tap ‚è∏Ô∏è to pause, üîÑ to reset</p>
      </section>
    </main>
  </div>

  <!-- ================= GAME PAGE ================= -->
  <div id="gamePage" class="gameWrap view">
    <header class="game">
      <div class="brand" style="gap:.5rem"><button id="btnHome" class="btn chip">üè†</button> PicklePong</div>
      <div class="hud">
        <button id="btnPause" class="btn chip" title="Pause/Resume">‚è∏Ô∏è Pause</button>
        <button id="btnReset" class="btn chip" title="Reset">üîÑ Reset</button>
        <button id="btnSound" class="btn chip" title="Sound on/off">üîä Sound</button>
        <span id="modeTag" class="btn chip" style="pointer-events:none"></span>
        <span id="score" aria-live="polite" style="min-width:64px;text-align:center"></span>
      </div>
    </header>

    <div class="crt">
      <canvas id="game" width="540" height="864" aria-label="PicklePong game area" role="img"></canvas>
      <section id="countdown" class="countdown"><div id="countNum" class="countNum">3</div></section>
    </div>
  </div>

  <script>
  (function(){
    // ===== Router =====
    const views = {
      home: document.getElementById('homePage'),
      game: document.getElementById('gamePage')
    };
    function show(id){ Object.values(views).forEach(v=>v.classList.remove('show')); views[id].classList.add('show'); }

    // ===== DOM =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const btnAddFC  = document.getElementById('btnAddFC');
    const playRegular = document.getElementById('playRegular');
    const playArcade  = document.getElementById('playArcade');

    const btnHome  = document.getElementById('btnHome');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
    const btnSound = document.getElementById('btnSound');

    const scoreEl = document.getElementById('score');
    const modeTag = document.getElementById('modeTag');

    const countdown = document.getElementById('countdown');
    const countNum  = document.getElementById('countNum');

    // ===== Settings (persist minimal) =====
    const saved = JSON.parse(localStorage.getItem('pp_settings')||'{}');
    const settings = {
      sound: saved.sound !== undefined ? saved.sound : true,
      difficulty: saved.difficulty || 'normal' // reserved for future
    };
    btnSound.textContent = settings.sound ? 'üîä Sound' : 'üîà Muted';

    // ===== Game State =====
    const court = { pad: 24, line: 4, netGap: 12 };
    const paddleW = 16, paddleH0 = 110, paddleR = 10;
    const player = { x: court.pad, y: H/2 - paddleH0/2, w: paddleW, h: paddleH0 };
    const cpu    = { x: W - court.pad - paddleW, y: H/2 - paddleH0/2, w: paddleW, h: paddleH0 };

    let running = false;
    let playerScore = 0, cpuScore = 0;
    let rally = 0;
    let mode = 'regular'; // or 'arcade'

    // Balls (arcade may add more later)
    let balls = [];

    // Arcade power-ups (very simple): PADDLE_PLUS (wider paddle), SLOW (slows ball briefly)
    const powerups = []; // {x,y,vy,type,ttl}
    const PU_TYPES = ['PADDLE_PLUS','SLOW'];
    let puSpawnTimer = 0;

    // Effects
    let effects = { paddlePlus:0, slowFactor:1 };

    // Sounds (tiny placeholders; many mobile browsers block autoplay so we keep it simple)
    const BLIP = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';
    const audio = { hit:new Audio(BLIP), wall:new Audio(BLIP), score:new Audio(BLIP) };
    function play(a){ if(settings.sound){ try{ a.currentTime=0; a.play(); }catch{} } }

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function rand(min,max){ return Math.random()*(max-min)+min; }
    function randSign(){ return Math.random()<.5?-1:1; }

    function difficultyParams(){
      // Slower base speeds (your request). Arcade gets a tiny bump.
      const base = { cpuFollow:1.9, rallyBoost:.04, ballSpeed:4.1, maxSpeed:10.5 }; // "normal"
      if(mode==='regular') return base;
      return { ...base, ballSpeed: base.ballSpeed+0.3, maxSpeed: base.maxSpeed+1.0 };
    }

    function makeBall(dir=randSign()){
      const p = difficultyParams();
      return { x:W/2, y:H/2, r:12, vx: p.ballSpeed*dir, vy: p.ballSpeed*(Math.random()*.5 - .25), maxSpeed:p.maxSpeed };
    }

    function resetRound(dir=randSign()){ balls = [ makeBall(dir) ]; rally = 0; }

    // ===== Draw helpers =====
    function roundRect(c, x, y, w, h, r){
      c.beginPath(); c.moveTo(x+r, y);
      c.arcTo(x+w, y, x+w, y+h, r);
      c.arcTo(x+w, y+h, x, y+h, r);
      c.arcTo(x, y+h, x, y, r);
      c.arcTo(x, y, x+w, y, r);
      c.closePath();
    }
    function drawCourt(){
      ctx.save();
      ctx.shadowColor = 'rgba(15,217,118,.55)';
      ctx.shadowBlur = 18;
      ctx.strokeStyle = 'rgba(15,217,118,.9)';
      ctx.lineWidth = court.line;
      ctx.strokeRect(court.pad, court.pad, W - court.pad*2, H - court.pad*2);
      ctx.setLineDash([court.line*2, court.netGap]);
      ctx.beginPath(); ctx.moveTo(W/2, court.pad); ctx.lineTo(W/2, H - court.pad); ctx.stroke(); ctx.setLineDash([]);
      ctx.restore();
    }
    function drawPaddle(p){
      const r=paddleR; const {x,y,w,h}=p;
      ctx.save();
      ctx.fillStyle='rgba(15,217,118,.15)'; ctx.strokeStyle='rgba(15,217,118,.9)'; ctx.lineWidth=2;
      roundRect(ctx,x,y,w,h,r); ctx.fill(); ctx.stroke();
      ctx.fillStyle='rgba(15,217,118,.35)'; ctx.fillRect(x - 6 + (p===cpu?12:0), y + h/2 - 12, 12, 24);
      ctx.restore();
    }
    function drawBall(b){
      // pickleball look with small perforations
      const holes = 6;
      ctx.save();
      ctx.fillStyle = '#f5e04c'; ctx.shadowColor='rgba(245,224,76,.55)'; ctx.shadowBlur=14;
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=0; ctx.fillStyle='rgba(0,0,0,.22)';
      for(let i=0;i<holes;i++){ const a=(i/holes)*Math.PI*2; const hx=b.x+Math.cos(a)*b.r*.55; const hy=b.y+Math.sin(a)*b.r*.4; ctx.beginPath(); ctx.arc(hx,hy,2.2,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
      // trail
      ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(15,217,118,.06)';
      ctx.beginPath(); ctx.arc(b.x - b.vx*1.2, b.y - b.vy*1.2, b.r*1.25, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
    function drawPowerup(pu){
      ctx.save();
      const icon = pu.type==='PADDLE_PLUS' ? '+' : '‚è±Ô∏è';
      ctx.fillStyle='rgba(15,217,118,.12)'; ctx.strokeStyle='rgba(15,217,118,.9)'; ctx.lineWidth=2;
      roundRect(ctx, pu.x-12, pu.y-12, 24, 24, 8); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#e6f1ff'; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(icon, pu.x, pu.y+1);
      ctx.restore();
    }

    // ===== Update/Physics =====
    function collideBallWithPaddle(b, p, params){
      if(b.x - b.r < p.x + p.w && b.x + b.r > p.x && b.y + b.r > p.y && b.y - b.r < p.y + p.h){
        const rel = (b.y - (p.y + p.h/2)) / (p.h/2);
        const speed = Math.min(Math.hypot(b.vx,b.vy)*1.06 + params.rallyBoost*rally, b.maxSpeed);
        const dir = (p===player) ? 1 : -1;
        const angle = rel * 0.7;
        b.vx = speed * dir * Math.cos(angle);
        b.vy = speed * Math.sin(angle);
        b.x = (p===player) ? p.x + p.w + b.r + 0.5 : p.x - b.r - 0.5;
        rally++; play(audio.hit);
      }
    }
    function rectIntersects(ax,ay,aw,ah, bx,by,bw,bh){ return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by; }

    function applyPowerup(type){
      if(type==='PADDLE_PLUS'){ effects.paddlePlus = Math.max(effects.paddlePlus, 8*60); player.h = paddleH0 + 40; }
      if(type==='SLOW'){ effects.slowFactor = Math.min(effects.slowFactor, 0.7); setTimeout(()=>{ effects.slowFactor=1; }, 6000); }
    }
    function tickEffects(){
      if(effects.paddlePlus>0){ effects.paddlePlus--; if(effects.paddlePlus===0){ player.h = paddleH0; } }
      if(mode==='arcade' && effects.slowFactor!==1){ for(const b of balls){ b.vx*=0.995; b.vy*=0.995; } }
    }

    function update(){
      if(!running) return;
      const params = difficultyParams();

      // move balls
      for(const b of balls){
        b.x += b.vx; b.y += b.vy;
        b.maxSpeed = params.maxSpeed;
        // walls
        if(b.y - b.r < court.pad){ b.y = court.pad + b.r; b.vy *= -1; play(audio.wall); }
        if(b.y + b.r > H - court.pad){ b.y = H - court.pad - b.r; b.vy *= -1; play(audio.wall); }
        // paddles
        collideBallWithPaddle(b, player, params);
        collideBallWithPaddle(b, cpu, params);
      }

      // scoring
      for(let i=balls.length-1;i>=0;i--){
        const b=balls[i];
        if(b.x < 0){ cpuScore++; play(audio.score); balls.splice(i,1); }
        else if(b.x > W){ playerScore++; play(audio.score); balls.splice(i,1); }
      }
      if(balls.length===0){ resetRound(randSign()); startCountdown(()=>{ running=true; }); }

      // CPU AI follows primary ball
      const b0 = balls[0] || { y:H/2, vy:0 };
      const target = b0.y - cpu.h/2 + clamp(b0.vy*12, -80, 80);
      const f = params.cpuFollow;
      cpu.y += clamp(target - cpu.y, -f, f);
      cpu.y = clamp(cpu.y, court.pad, H - court.pad - cpu.h);

      // clamp player
      player.y = clamp(player.y, court.pad, H - court.pad - player.h);

      // Arcade powerups
      if(mode==='arcade'){
        puSpawnTimer++;
        if(puSpawnTimer > 90){ puSpawnTimer=0; if(Math.random()<0.06){ powerups.push({ x: rand(court.pad+30, W-court.pad-30), y: court.pad+30, vy: 1.2, type: PU_TYPES[Math.floor(Math.random()*PU_TYPES.length)], ttl: 20*60 }); } }
        for(let i=powerups.length-1;i>=0;i--){
          const pu = powerups[i]; pu.y += pu.vy; pu.ttl--;
          if(pu.ttl<=0 || pu.y>H-court.pad-16){ powerups.splice(i,1); continue; }
          if(rectIntersects(pu.x-12, pu.y-12, 24,24, player.x, player.y, player.w, player.h)){
            applyPowerup(pu.type); powerups.splice(i,1); play(audio.hit);
          }
        }
      } else powerups.length=0;

      // HUD
      scoreEl.textContent = `üèì ${playerScore} : ${cpuScore}`;
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawCourt();
      drawPaddle(player); drawPaddle(cpu);
      for(const b of balls) drawBall(b);
      if(mode==='arcade'){ for(const pu of powerups) drawPowerup(pu); }
    }

    // ===== Loop =====
    function loop(){
      if(running) tickEffects();
      update(); draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop); // start immediately

    // ===== Input =====
    const drag = { active:false, oy:0, py:0 };
    function pointerY(e){ return (e.touches? e.touches[0].clientY : e.clientY) - canvas.getBoundingClientRect().top; }
    function startDrag(e){ drag.active=true; drag.oy=pointerY(e); drag.py=player.y; }
    function moveDrag(e){ if(!drag.active) return; const dy = pointerY(e)-drag.oy; player.y = drag.py + dy; }
    function endDrag(){ drag.active=false; }
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
    canvas.addEventListener('touchstart', startDrag, {passive:true});
    canvas.addEventListener('touchmove', moveDrag, {passive:true});
    canvas.addEventListener('touchend', endDrag, {passive:true});

    window.addEventListener('keydown', (e)=>{
      if(e.key==='ArrowUp'||e.key==='w') player.y -= 28;
      if(e.key==='ArrowDown'||e.key==='s') player.y += 28;
      if(e.key===' ') togglePause();
      if(e.key==='Escape'){ running=false; show('home'); }
    });

    // ===== Buttons =====
    playRegular.onclick = ()=> startGame('regular');
    playArcade.onclick  = ()=> startGame('arcade');
    btnAddFC.onclick = addToFarcaster;

    btnHome.onclick = ()=>{ running=false; show('home'); };
    btnPause.onclick = togglePause;
    btnReset.onclick = ()=>{ playerScore=0; cpuScore=0; resetRound(randSign()); running=false; startCountdown(()=>{ running=true; }); };
    btnSound.onclick = ()=>{ settings.sound=!settings.sound; btnSound.textContent = settings.sound? 'üîä Sound':'üîà Muted'; localStorage.setItem('pp_settings', JSON.stringify(settings)); };

    function startGame(m){
      mode = m;
      show('game');
      modeTag.textContent = m==='regular' ? 'REGULAR' : 'ARCADE';
      // reset actors & effects
      playerScore=0; cpuScore=0; rally=0;
      player.y=H/2 - paddleH0/2; player.h = paddleH0;
      cpu.y=H/2 - paddleH0/2; effects={paddlePlus:0,slowFactor:1}; powerups.length=0;
      resetRound(randSign());
      running=false;
      startCountdown(()=>{ running=true; });
    }

    function togglePause(){ running=!running; btnPause.textContent = running? '‚è∏Ô∏è Pause':'‚ñ∂Ô∏è Resume'; }

    function startCountdown(done){
      let n=3; countNum.textContent=n; countdown.classList.add('show');
      const t = setInterval(()=>{
        n--;
        if(n>0){ countNum.textContent=n; play(audio.hit); }
        else {
          clearInterval(t); countNum.textContent='GO!'; play(audio.wall);
          setTimeout(()=>{ countdown.classList.remove('show'); done&&done(); }, 450);
        }
      }, 700);
    }

    async function addToFarcaster(){
      try{
        if(window.farcasterSDK?.actions?.share){
          await window.farcasterSDK.actions.share({ url: location.href, text: 'Play PicklePong Mini!' });
        } else if(navigator.share){
          await navigator.share({ url: location.href, text: 'Play PicklePong Mini!' });
        } else {
          await navigator.clipboard.writeText(location.href);
          alert('Link copied! Cast this URL to add it.');
        }
      }catch(e){
        try{ await navigator.clipboard.writeText(location.href); alert('Link copied!'); }catch{}
      }
    }

    // Tell Farcaster we're ready (no-op in preview)
    (async () => { try{ await window.farcasterSDK.actions.ready(); } catch(e){} })();
  })();
  </script>
</body>
</html>
