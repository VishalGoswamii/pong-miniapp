<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Pong • Pickleball Theme</title>

  <!-- Farcaster Mini App embed (Vercel domain + root images) -->
  <meta name="fc:miniapp" content='{
    "version": "1",
    "imageUrl": "https://pong-miniapp.vercel.app/og.png",
    "button": {
      "title": "Play Pong",
      "action": {
        "type": "launch_frame",
        "name": "Pong",
        "url": "https://pong-miniapp.vercel.app/",
        "splashImageUrl": "https://pong-miniapp.vercel.app/icon-200.png",
        "splashBackgroundColor": "#0f172a"
      }
    }
  }' />

  <!-- PeerJS for online 1v1 (deferred; safe-guarded) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.5/peerjs.min.js" defer></script>

  <style>
    :root{
      --courtOuter:#061429; --courtMain:#1E40AF; --courtKitchen:#ef4444; --courtLine:#F8FAFC;
      --centerRed:#ef4444; --ballY:#FDE047; --paddleFace:#D4DEE9; --paddleEdge:#425C7A;
    }
    html, body { margin:0; height:100%; background:var(--courtOuter); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #wrap { position:fixed; inset:0; z-index:0; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    #score { position:fixed; top:calc(env(safe-area-inset-top) + 10px); left:50%; transform:translateX(-50%);
      color:#fff; font-weight:1000; letter-spacing:1.2px; font-size:28px; padding:8px 14px; border-radius:16px;
      background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.07));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16), 0 14px 40px rgba(0,0,0,0.45);
    }
    #score.bump { animation: bump .18s ease; }
    @keyframes bump { 50% { transform: translateX(-50%) scale(1.08);} }

    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:2; }
    #overlay.hidden { display:none; }
    .card { background: rgba(12,18,32,0.86);
      border:1px solid rgba(255,255,255,0.14); color:#e9f1ff; padding:26px 22px; border-radius:18px; text-align:center;
      box-shadow: 0 28px 90px rgba(0,0,0,0.55); max-width:620px; margin:24px; }
    .title { margin:6px 0 2px; font-size:32px; font-weight:1000; color:#fff; }
    .sub { margin-top:8px; opacity:0.85; }

    .mode-grid { display:grid; grid-template-columns:1fr; gap:14px; margin-top:14px; }
    .mode { display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px; border:1px solid rgba(255,255,255,0.18); border-radius:14px; background:rgba(255,255,255,0.05); }
    .mode h3 { margin:0; font-size:18px; }
    .mode p  { margin:0; font-size:13px; opacity:.9; }

    .row { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px; }
    button { padding:12px 16px; border-radius:14px; border:1px solid rgba(255,255,255,0.18); font-weight:900; font-size:15px; cursor:pointer; }
    .primary { color:#08111a; background:#60A5FA; box-shadow: 0 8px 24px rgba(37,99,235,.45), inset 0 0 0 1px rgba(255,255,255,0.18); }
    .ghost   { color:#e9f1ff; background:transparent; }

    #hint { position:fixed; bottom:calc(env(safe-area-inset-bottom) + 10px); left:0; right:0; text-align:center; color:#e7f2ff; font-size:13px; opacity:.9; }

    /* player badges */
    #players { position:fixed; top:calc(env(safe-area-inset-top) + 54px); left:0; right:0; display:flex; justify-content:space-between; padding:0 10px; pointer-events:none; }
    .pb { display:flex; align-items:center; gap:8px; background:rgba(12,18,32,.6); border:1px solid rgba(255,255,255,.14);
      color:#eaf3ff; padding:6px 10px; border-radius:999px; min-width:120px; }
    .pb img { width:24px; height:24px; border-radius:999px; object-fit:cover; background:#0f172a; }
    .pb .name { font-weight:800; font-size:13px; }
    .pb .tag  { font-size:12px; opacity:.8; }

    /* tiny toasts */
    #toast { position:fixed; top:calc(env(safe-area-inset-top) + 10px); right:10px; color:#fff; background:rgba(0,0,0,.6); padding:8px 10px; border-radius:10px; font-size:12px; display:none; }
    #toast.show { display:block; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Pong"></canvas></div>
  <div id="score" aria-live="polite">0 : 0</div>

  <div id="players">
    <div class="pb" id="p1"><img id="p1img" alt=""><div><div class="name" id="p1name">You</div><div class="tag">P1</div></div></div>
    <div class="pb" id="p2"><img id="p2img" alt=""><div><div class="name" id="p2name">CPU</div><div class="tag" id="p2tag">AI</div></div></div>
  </div>

  <div id="overlay">
    <div class="card home">
      <h1 class="title">PONG</h1>
      <p class="sub">Pickleball blue court • red kitchen • beat your opponent</p>

      <div class="mode-grid">
        <div class="mode">
          <div>
            <h3>Single Player (vs AI)</h3>
            <p>Fast, fair AI. Drag anywhere to move.</p>
          </div>
          <button class="primary" id="btnSingle">Play</button>
        </div>

        <div class="mode">
          <div>
            <h3>Online 1v1 (Quick Match)</h3>
            <p>Tap to find the next available player on the server.</p>
          </div>
          <button class="primary" id="btnFind">Find Match</button>
        </div>
      </div>
    </div>
  </div>

  <div id="hint">Swipe/drag to move. Online mode requires both players to open the app.</div>
  <div id="toast"></div>

  <script>
  'use strict';
  /*********** DOM ***********/
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false }) || canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const p1img = document.getElementById('p1img'), p1name = document.getElementById('p1name');
  const p2img = document.getElementById('p2img'), p2name = document.getElementById('p2name'), p2tag = document.getElementById('p2tag');
  const toast = document.getElementById('toast');

  const btnSingle = document.getElementById('btnSingle');
  const btnFind   = document.getElementById('btnFind');

  const vib = (ms)=>{ try{ if(navigator.vibrate) navigator.vibrate(ms);}catch(e){} };
  function showToast(t){ toast.textContent = t; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 2500); }

  /*********** Farcaster user (username + pfp) ***********/
  function readMiniUser(){
    try {
      const c1 = window.__fc_sdk && window.__fc_sdk.context;
      const c2 = window.farcaster && window.farcaster.sdk && window.farcaster.sdk.context;
      const c3 = window.frame && window.frame.sdk && window.frame.sdk.context;
      const c4 = window.sdk && window.sdk.context;
      const cx = c1 || c2 || c3 || c4;
      if (cx && cx.user) return cx.user; // { fid, username, displayName, pfpUrl }
    } catch(e){}
    return null;
  }
  function setPlayerBadge(elImg, elName, obj, fallbackTag){
    if (obj) {
      elName.textContent = obj.displayName || obj.username || ('fid ' + obj.fid);
      if (obj.pfpUrl) { elImg.src = obj.pfpUrl; elImg.alt = elName.textContent; }
      else { elImg.removeAttribute('src'); elImg.alt = ''; }
    } else {
      elName.textContent = fallbackTag || 'Guest';
      elImg.removeAttribute('src'); elImg.alt = '';
    }
  }
  const me = readMiniUser(); // may be null outside Farcaster
  setPlayerBadge(p1img, p1name, me, 'You');

  /*********** Game state ***********/
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=0, H=0, last=0, running=false, paused=false, noScoreUntil=0;

  const paddle = { w: 4*dpr, h: 70*dpr };
  let playerY=0, oppY=0;
  const ball = { x:0, y:0, r:9, vx:0, vy:0, baseSpeed:380 };
  let speedMul = 1.0; // single speed

  let scoreL=0, scoreR=0;

  // AI
  let aiOn = true;
  let aiSpeed = 330 * dpr;
  const aiNoise = 26 * dpr;

  // Online (PeerJS)
  let MODE = 'home';          // 'single' | 'online-host' | 'online-guest'
  let peer = null, conn = null, isHost = false, netLastSend = 0;
  let oppUser = null;

  // Trail (#7)
  const trail = [];

  // New logic
  let rallyHits = 0;              // rally speed curve
  let lastPointerY = null, pointerVy = 0; // spin
  let flatTimer = 0;              // anti-stall
  const POINTS_TO_WIN = 11;       // win by 2

  function resize(){
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    W = canvas.width; H = canvas.height;
    paddle.h = Math.max(56*dpr, Math.min(H*0.16, 86*dpr)) * 0.90;
    if (!running && last===0){ playerY = H/2; oppY = H/2; ball.x = W/2; ball.y = H/2; }
    noScoreUntil = performance.now() + 250;
    draw();
  }
  addEventListener('resize', resize);

  const clamp = (v,min,max) => v<min?min:v>max?max:v;
  const css = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

  function resetBall(dir=1){
    ball.x = W/2; ball.y = H/2;
    const angle = (Math.random()*0.5 - 0.25);
    const sp = ball.baseSpeed * speedMul * dpr;
    ball.vx = Math.cos(angle) * sp * dir;
    ball.vy = Math.sin(angle) * sp;
    playerY = H/2; oppY = H/2;
    noScoreUntil = performance.now() + 200;
    trail.length = 0; // clear trail
  }

  // Input (pointer + touch) with spin sampling
  function updateFromPointerLike(clientY){
    const r = canvas.getBoundingClientRect();
    const y = (clientY - r.top) * dpr;
    // compute swipe velocity for spin
    if (lastPointerY != null) pointerVy = (clientY - (r.top + lastPointerY/dpr)) * dpr; // robust
    lastPointerY = (y); // store in canvas space
    playerY = clamp(y, paddle.h/2, H - paddle.h/2);
    if (MODE === 'online-guest' && conn && conn.open) {
      try { conn.send({ t:'in', y: playerY }); } catch(e){}
    }
  }
  function onPointer(e){ updateFromPointerLike(e.clientY); e.preventDefault(); }
  function onTouch(e){
    if (!e.touches || !e.touches[0]) return;
    updateFromPointerLike(e.touches[0].clientY); e.preventDefault();
  }

  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ dragging=true; if(!running) startSingleIfNeeded(); onPointer(e); }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{ if(!dragging) return; onPointer(e); }, {passive:false});
  canvas.addEventListener('pointerup', ()=> { dragging=false; lastPointerY=null; pointerVy=0; }, {passive:true});
  canvas.addEventListener('pointercancel', ()=> { dragging=false; lastPointerY=null; pointerVy=0; }, {passive:true});

  canvas.addEventListener('touchstart', (e)=>{ dragging=true; if(!running) startSingleIfNeeded(); onTouch(e); }, {passive:false});
  canvas.addEventListener('touchmove',  (e)=>{ if(!dragging) return; onTouch(e); }, {passive:false});
  canvas.addEventListener('touchend',   ()=> { dragging=false; lastPointerY=null; pointerVy=0; }, {passive:true});
  canvas.addEventListener('touchcancel',()=> { dragging=false; lastPointerY=null; pointerVy=0; }, {passive:true});

  function startSingleIfNeeded(){ if (MODE === 'single' && !running) startGame(); }

  /*********** Rendering ***********/
  function drawCourt(){
    if (!ctx) return;
    ctx.fillStyle = css('--courtOuter'); ctx.fillRect(0,0,W,H);
    ctx.fillStyle = css('--courtMain'); ctx.fillRect(0,0,W,H);
    const kW = W * (7/44);
    ctx.fillStyle = css('--courtKitchen');
    ctx.fillRect(W/2 - kW, 0, kW, H);
    ctx.fillRect(W/2, 0, kW, H);
    ctx.save();
    ctx.strokeStyle = css('--courtLine');
    ctx.lineWidth = 3*dpr; ctx.lineCap='square';
    ctx.strokeRect(1.5*dpr, 1.5*dpr, W-3*dpr, H-3*dpr);
    ctx.setLineDash([10*dpr, 14*dpr]);
    ctx.strokeStyle = css('--centerRed'); ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
    ctx.setLineDash([]); ctx.strokeStyle = css('--courtLine');
    ctx.beginPath(); ctx.moveTo(W/2 - kW, 0); ctx.lineTo(W/2 - kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W/2 + kW, 0); ctx.lineTo(W/2 + kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
    ctx.restore();
  }
  function drawPaddle(x,y,w,h){
    ctx.fillStyle = css('--paddleFace');
    const r = Math.min(6*dpr, w);
    ctx.beginPath();
    ctx.moveTo(x, y-h/2+r);
    ctx.arcTo(x, y-h/2, x+w, y-h/2, r);
    ctx.arcTo(x+w, y-h/2, x+w, y+h/2, r);
    ctx.arcTo(x+w, y+h/2, x, y+h/2, r);
    ctx.arcTo(x, y+h/2, x, y-h/2, r);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = 1*dpr; ctx.strokeStyle = css('--paddleEdge'); ctx.stroke();
  }
  function drawBall(){
    // trail (#7)
    for (let i=0;i<trail.length;i++){
      const t = i / trail.length;
      ctx.globalAlpha = t * 0.5;
      ctx.beginPath(); ctx.arc(trail[i].x, trail[i].y, (ball.r*dpr) * (0.6 + 0.4*t), 0, Math.PI*2);
      ctx.fillStyle = css('--ballY'); ctx.fill();
    }
    ctx.globalAlpha = 1;
    // main ball
    const rr = ball.r*dpr;
    ctx.fillStyle = css('--ballY');
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth = 1.2*dpr; ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.stroke();
  }
  function draw(){
    if (!ctx) return;
    drawCourt();
    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    drawPaddle(px, playerY, paddle.w, paddle.h);
    drawPaddle(ax, oppY,     paddle.w, paddle.h);
    drawBall();
  }

  /*********** Step (host or single) ***********/
  function stepHostOrSingle(dt){
    const oldX = ball.x;
    const r = ball.r * dpr;
    ball.x += ball.vx * dt; ball.y += ball.vy * dt;

    // record trail position (#7)
    trail.push({x:ball.x, y:ball.y}); if (trail.length > 10) trail.shift();

    // anti-stall (flat) nudge
    if (Math.abs(ball.vy) < 30 * dpr) flatTimer += dt; else flatTimer = 0;
    if (flatTimer > 1.2) { ball.vy += (Math.random() > 0.5 ? 1 : -1) * 60 * dpr; flatTimer = 0; }

    // walls
    if (ball.y < r) { ball.y = r; ball.vy *= -1; }
    if (ball.y > H - r) { ball.y = H - r; ball.vy *= -1; }

    // paddles
    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    const pTop = playerY - paddle.h/2, pBot = playerY + paddle.h/2;
    const aTop = oppY - paddle.h/2, aBot = oppY + paddle.h/2;

    if (ball.vx < 0) {
      if (ball.x - r <= px + paddle.w && ball.x - r >= px && ball.y >= pTop && ball.y <= pBot) {
        ball.x = px + paddle.w + r;
        const t = (ball.y - playerY) / (paddle.h/2);
        ball.vx = Math.abs(ball.vx) * 1.01;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);

        // player spin via swipe
        ball.vy += pointerVy * 5; pointerVy = 0;

        // rally-based speed curve
        rallyHits = Math.min(rallyHits + 1, 12);
        const boost = 1 + Math.min(rallyHits * 0.015, 0.18);
        ball.vx *= boost; ball.vy *= boost;

        // clamp bounce angles (fairness)
        const speed = Math.hypot(ball.vx, ball.vy);
        let angle = Math.atan2(ball.vy, Math.abs(ball.vx));
        const maxAngle = Math.PI * 0.36; // ~65°
        angle = Math.max(-maxAngle, Math.min(maxAngle, angle));
        ball.vx = Math.cos(angle) * speed * 1; // moving right
        ball.vy = Math.sin(angle) * speed;

        // clamp runaway speed
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }

        vib(10);
      }
    } else {
      if (ball.x + r >= ax && ball.x + r <= ax + paddle.w && ball.y >= aTop && ball.y <= aBot) {
        ball.x = ax - r;
        const t = (ball.y - oppY) / (paddle.h/2);
        ball.vx = -Math.abs(ball.vx) * 1.02;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);

        // rally-based speed curve
        rallyHits = Math.min(rallyHits + 1, 12);
        const boost = 1 + Math.min(rallyHits * 0.015, 0.18);
        ball.vx *= boost; ball.vy *= boost;

        // clamp bounce angles (fairness)
        const speed = Math.hypot(ball.vx, ball.vy);
        let angle = Math.atan2(ball.vy, Math.abs(ball.vx));
        const maxAngle = Math.PI * 0.36; // ~65°
        angle = Math.max(-maxAngle, Math.min(maxAngle, angle));
        ball.vx = -Math.cos(angle) * speed; // moving left
        ball.vy =  Math.sin(angle) * speed;

        // clamp runaway speed
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }

        vib(10);
      }
    }

    // scoring (after small grace)
    if (performance.now() >= noScoreUntil) {
      const leftCross  = (ball.vx < 0) && ((oldX + r) >= 0) && ((ball.x + r) < 0);
      const rightCross = (ball.vx > 0) && ((oldX - r) <= W) && ((ball.x - r) > W);
      if (leftCross) { score('R'); return; }
      if (rightCross){ score('L'); return; }
    }

    // AI move (only in single-player)
    if (aiOn) {
      const target = clamp(ball.y + (Math.random()*2-1)*aiNoise, paddle.h/2, H - paddle.h/2);
      const dy = target - oppY; const maxStep = aiSpeed * dt; oppY += clamp(dy, -maxStep, maxStep);
      oppY = clamp(oppY, paddle.h/2, H - paddle.h/2);
    }

    // clamp paddle
    playerY = clamp(playerY, paddle.h/2, H - paddle.h/2);

    draw();

    // send state to guest if online host
    if (MODE === 'online-host' && conn && conn.open) {
      const now = performance.now();
      if (now - netLastSend > 33) { // ~30fps
        netLastSend = now;
        try { conn.send({ t:'st', x:ball.x, y:ball.y, vx:ball.vx, vy:ball.vy, p1:playerY, p2:oppY, sl:scoreL, sr:scoreR, w:W, h:H }); } catch(e){}
      }
    }
  }

  function score(side){
    if (side === 'L') scoreL++; else scoreR++;
    scoreEl.textContent = scoreL + " : " + scoreR;
    scoreEl.classList.remove('bump'); void scoreEl.offsetWidth; scoreEl.classList.add('bump');

    // Dynamic AI
    const diff = scoreL - scoreR; // positive when you lead
    if (diff <= -2) { aiSpeed = 300 * dpr; }    // easier if you're losing
    else if (diff >= 2) { aiSpeed = 360 * dpr; } // tougher if you're winning
    else { aiSpeed = 330 * dpr; }               // neutral

    // Comeback assist: ball a bit bigger when behind
    ball.r = (diff <= -2) ? 11 : 9;

    // Win condition: to 11, win by 2
    const lead = Math.abs(scoreL - scoreR);
    if ((scoreL >= POINTS_TO_WIN || scoreR >= POINTS_TO_WIN) && lead >= 2) {
      running = false;
      overlay.classList.remove('hidden');
      const t = document.querySelector('.card.home .title');
      if (t) t.textContent = (scoreL > scoreR ? 'You win!' : 'You lose');
      setTimeout(()=>{ if (t) t.textContent = 'PONG'; }, 1200);
      vib(20);
      return;
    }

    // reset rally for next serve
    rallyHits = 0;

    vib(15);
    resetBall(side === 'L' ? -1 : 1);
  }

  function loop(ts){
    const dt = Math.min(0.02, ((last===0? ts-16 : ts) - last)/1000 || 0.016);
    last = ts;
    if (!paused) {
      if (MODE === 'single' || MODE === 'online-host') stepHostOrSingle(dt);
      if (MODE === 'online-guest') draw();
    }
    if (running) requestAnimationFrame(loop);
  }

  /*********** Start flows ***********/
  function startGame(){
    scoreL=0; scoreR=0; scoreEl.textContent = "0 : 0";
    playerY = H/2; oppY = H/2;
    rallyHits = 0; flatTimer = 0; ball.r = 9;
    resetBall(Math.random()<0.5? -1 : 1);
    overlay.classList.add('hidden');
    paused=false; running=true; last=0;
    requestAnimationFrame(loop);
  }
  function setBadgesForSingle(){
    setPlayerBadge(p1img, p1name, me, 'You');
    setPlayerBadge(p2img, p2name, { displayName:'CPU' }, 'CPU'); p2tag.textContent = 'AI';
  }

  btnSingle && btnSingle.addEventListener('click', ()=>{
    MODE = 'single'; aiOn = true;
    setBadgesForSingle();
    startGame();
  });

  // QUICK MATCH (needs /api/match + Vercel KV configured)
  btnFind && btnFind.addEventListener('click', async () => {
    showToast('Looking for an opponent…');
    if (!window.Peer) { showToast('Loading network libs… try again'); return; }

    isHost = false; // unknown yet
    peer = new Peer(); // uses PeerJS cloud signalling

    // If someone connects to us first -> we are HOST
    peer.on('connection', c => {
      MODE = 'online-host'; aiOn = false; conn = c;
      setPlayerBadge(p1img, p1name, me, 'You');
      setPlayerBadge(p2img, p2name, null, 'Player 2'); p2tag.textContent = 'P2';
      overlay.classList.add('hidden');
      conn.on('data', onNetDataFromGuest);
      conn.on('close', () => { showToast('Player left'); endOnline(); });
      startGame();
      const u = me || {};
      try { conn.send({ t:'hi', u: { fid:u.fid, username:u.username, displayName:u.displayName, pfpUrl:u.pfpUrl } }); } catch(e){}
    });

    peer.on('error', e => { showToast('Network error'); console.warn(e); endOnline(); });

    peer.on('open', async (id) => {
      const u = me || {};
      let resp;
      try {
        resp = await fetch('/api/match', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ peerId: id, user: { fid:u.fid, username:u.username, displayName:u.displayName, pfpUrl:u.pfpUrl } })
        }).then(r => r.json());
      } catch (e) {
        showToast('Match server unreachable');
        return endOnline();
      }

      if (resp && resp.opponentPeerId) {
        MODE = 'online-guest'; aiOn = false; overlay.classList.add('hidden');
        conn = peer.connect(resp.opponentPeerId);
        conn.on('open', () => {
          const u = me || {};
          try { conn.send({ t:'hi', u: { fid:u.fid, username:u.username, displayName:u.displayName, pfpUrl:u.pfpUrl } }); } catch(e){}
          running = true; last = 0; requestAnimationFrame(loop);
        });
        conn.on('data', onNetDataFromHost);
        conn.on('close', () => { showToast('Disconnected'); endOnline(); });
        setPlayerBadge(p2img, p2name, me, 'You'); p2tag.textContent = 'P2';
      } else if (resp && resp.wait) {
        showToast('Waiting for opponent…');
      } else {
        showToast('Match error');
        endOnline();
      }
    });
  });

  function endOnline(){
    running=false; overlay.classList.remove('hidden');
    try { conn && conn.close(); } catch(e){}
    try { peer && peer.destroy(); } catch(e){}
    conn=null; peer=null; MODE='home';
  }

  // host receives guest input / hello
  function onNetDataFromGuest(msg){
    if (!msg || typeof msg !== 'object') return;
    if (msg.t === 'in') {
      oppY = clamp(msg.y, paddle.h/2, H - paddle.h/2);
    } else if (msg.t === 'hi') {
      oppUser = msg.u || null;
      setPlayerBadge(p2img, p2name, oppUser, 'Player 2'); p2tag.textContent = 'P2';
    }
  }
  // guest receives state / hello
  function onNetDataFromHost(msg){
    if (!msg || typeof msg !== 'object') return;
    if (msg.t === 'st') {
      ball.x=msg.x; ball.y=msg.y; ball.vx=msg.vx; ball.vy=msg.vy;
      playerY=msg.p1; oppY=msg.p2; scoreL=msg.sl; scoreR=msg.sr;
      scoreEl.textContent = scoreL + " : " + scoreR;
      if (W!==msg.w || H!==msg.h) resize();
      draw();
    } else if (msg.t === 'hi') {
      oppUser = msg.u || null;
      setPlayerBadge(p1img, p1name, oppUser, 'P1');
      setPlayerBadge(p2img, p2name, me, 'You'); p2tag.textContent = 'P2';
    }
  }

  /*********** Boot ***********/
  function init(){ resize(); draw(); }
  init();
  </script>

  <!-- Farcaster: hide splash once ready (robust, no imports) -->
  <script>
  (function () {
    function callReadyFrom(obj){
      try{
        if (obj && obj.actions && typeof obj.actions.ready === 'function') { obj.actions.ready(); return true; }
      }catch(e){}
      return false;
    }
    function tryAll(){
      if (callReadyFrom(window.__fc_sdk)) return true;
      if (window.farcaster && callReadyFrom(window.farcaster.sdk)) return true;
      if (window.frame && callReadyFrom(window.frame.sdk)) return true;
      if (callReadyFrom(window.sdk)) return true;
      return false;
    }
    if (!tryAll()) {
      requestAnimationFrame(function(){ requestAnimationFrame(tryAll); });
      var tries = 0, t = setInterval(function(){ if (tryAll() || ++tries > 60) clearInterval(t); }, 100);
    }
  })();
  </script>
</body>
</html>
