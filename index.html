<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Pong • Pickleball Theme</title>

  <!-- Farcaster Mini App embed (Vercel domain + root images) -->
  <meta name="fc:miniapp" content='{
    "version": "1",
    "imageUrl": "https://pong-miniapp.vercel.app/og.png",
    "button": {
      "title": "Play Pong",
      "action": {
        "type": "launch_frame",
        "name": "Pong",
        "url": "https://pong-miniapp.vercel.app/",
        "splashImageUrl": "https://pong-miniapp.vercel.app/icon-200.png",
        "splashBackgroundColor": "#0f172a"
      }
    }
  }' />
  <!-- Optional fallback for older clients -->
  <meta name="fc:frame" content='{
    "version": "1",
    "imageUrl": "https://pong-miniapp.vercel.app/og.png",
    "button": {
      "title": "Play Pong",
      "action": {
        "type": "launch_frame",
        "name": "Pong",
        "url": "https://pong-miniapp.vercel.app/",
        "splashImageUrl": "https://pong-miniapp.vercel.app/icon-200.png",
        "splashBackgroundColor": "#0f172a"
      }
    }
  }' />

  <style>
    /* keep your existing CSS here (unchanged) */
  </style>
</head>


<body>
  <div id="wrap"><canvas id="game" aria-label="Pong"></canvas></div>
  <div id="score" aria-live="polite">0 : 0</div>
  <div id="overlay">
    <div class="card home">
      <h1 class="title">PONG</h1>
      <div class="brand">Pickleball Theme</div>
      <p class="sub">Classic Pong • Drag to move • Beat the AI</p>
      <div class="actions">
        <label class="brand" style="display:flex;align-items:center;gap:8px;">
          Speed
          <select id="speedMode">
            <option value="slow" selected>Slow</option>
            <option value="normal">Normal</option>
            <option value="fast">Fast</option>
          </select>
        </label>
        <button id="play" onclick="window.startGame && window.startGame()">Play</button>
      </div>
    </div>
  </div>
  <div id="hint">Blue court, red kitchen. Pure Pong.</div>

  <script>
  'use strict';
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');

  function bindUI(){
    const playBtn = document.getElementById('play');
    if (playBtn) playBtn.addEventListener('click', start, { passive:true });
  }
  if (document.readyState !== 'loading') bindUI(); else document.addEventListener('DOMContentLoaded', bindUI);

  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=0, H=0, last=0, running=false, paused=false, noScoreUntil=0;

  const paddle = { w: 4*dpr, h: 70*dpr };
  let playerY=0, aiY=0;
  const ball = { x:0, y:0, r:9, vx:0, vy:0, baseSpeed:380 };
  let speedMul = 0.75; // default slow

  let scoreL=0, scoreR=0;
  let aiSpeed = 300 * dpr;
  const aiNoise = 26 * dpr;

  function resize(){
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    W = canvas.width; H = canvas.height;
    paddle.h = Math.max(56*dpr, Math.min(H*0.16, 86*dpr)) * 0.90;
    if (!running && last===0){ playerY = H/2; aiY = H/2; ball.x = W/2; ball.y = H/2; }
    noScoreUntil = performance.now() + 250;
    draw();
  }
  addEventListener('resize', resize);

  const clamp = (v,min,max) => v<min?min:v>max?max:v;
  const css = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

  function resetBall(dir=1){
    ball.x = W/2; ball.y = H/2;
    const angle = (Math.random()*0.5 - 0.25);
    const sp = ball.baseSpeed * speedMul * dpr;
    ball.vx = Math.cos(angle) * sp * dir;
    ball.vy = Math.sin(angle) * sp;
    playerY = H/2; aiY = H/2;
    noScoreUntil = performance.now() + 200;
  }

  function updateFromPointer(e){
    const r = canvas.getBoundingClientRect();
    const y = (e.clientY - r.top) * dpr;
    playerY = clamp(y, paddle.h/2, H - paddle.h/2);
    e.preventDefault();
  }
  let dragging=false;
  canvas.addEventListener('pointerdown', (e)=>{ dragging=true; if(!running) start(); updateFromPointer(e); }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{ if(!dragging) return; updateFromPointer(e); }, {passive:false});
  canvas.addEventListener('pointerup', ()=> dragging=false, {passive:true});
  canvas.addEventListener('pointercancel', ()=> dragging=false, {passive:true});

  function drawCourt(){
    ctx.fillStyle = css('--courtOuter'); ctx.fillRect(0,0,W,H);
    ctx.fillStyle = css('--courtMain'); ctx.fillRect(0,0,W,H);
    const kW = W * (7/44);
    ctx.fillStyle = css('--courtKitchen');
    ctx.fillRect(W/2 - kW, 0, kW, H);
    ctx.fillRect(W/2, 0, kW, H);
    ctx.save();
    ctx.strokeStyle = css('--courtLine');
    ctx.lineWidth = 3*dpr; ctx.lineCap='square';
    ctx.strokeRect(1.5*dpr, 1.5*dpr, W-3*dpr, H-3*dpr);
    ctx.setLineDash([10*dpr, 14*dpr]);
    ctx.strokeStyle = css('--centerRed'); ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
    ctx.setLineDash([]); ctx.strokeStyle = css('--courtLine');
    ctx.beginPath(); ctx.moveTo(W/2 - kW, 0); ctx.lineTo(W/2 - kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W/2 + kW, 0); ctx.lineTo(W/2 + kW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
    ctx.restore();
  }

  function drawPaddle(x,y,w,h){
    ctx.fillStyle = css('--paddleFace');
    const r = Math.min(6*dpr, w);
    ctx.beginPath();
    ctx.moveTo(x, y-h/2+r);
    ctx.arcTo(x, y-h/2, x+w, y-h/2, r);
    ctx.arcTo(x+w, y-h/2, x+w, y+h/2, r);
    ctx.arcTo(x+w, y+h/2, x, y+h/2, r);
    ctx.arcTo(x, y+h/2, x, y-h/2, r);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = 1*dpr; ctx.strokeStyle = css('--paddleEdge'); ctx.stroke();
  }

  function drawBall(){
    const rr = ball.r*dpr;
    ctx.fillStyle = css('--ballY');
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth = 1.2*dpr; ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, rr, 0, Math.PI*2); ctx.stroke();
  }

  function draw(){
    drawCourt();
    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    drawPaddle(px, playerY, paddle.w, paddle.h);
    drawPaddle(ax, aiY,     paddle.w, paddle.h);
    drawBall();
  }

  function step(dt){
    const oldX = ball.x;
    const r = ball.r * dpr;
    ball.x += ball.vx * dt; ball.y += ball.vy * dt;

    if (ball.y < r) { ball.y = r; ball.vy *= -1; }
    if (ball.y > H - r) { ball.y = H - r; ball.vy *= -1; }

    const px = 22*dpr, ax = W - (22*dpr + paddle.w);
    const pTop = playerY - paddle.h/2, pBot = playerY + paddle.h/2;
    const aTop = aiY - paddle.h/2, aBot = aiY + paddle.h/2;

    if (ball.vx < 0) {
      if (ball.x - r <= px + paddle.w && ball.x - r >= px && ball.y >= pTop && ball.y <= pBot) {
        ball.x = px + paddle.w + r;
        const t = (ball.y - playerY) / (paddle.h/2);
        ball.vx = Math.abs(ball.vx) * 1.01;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }
      }
    } else {
      if (ball.x + r >= ax && ball.x + r <= ax + paddle.w && ball.y >= aTop && ball.y <= aBot) {
        ball.x = ax - r;
        const t = (ball.y - aiY) / (paddle.h/2);
        ball.vx = -Math.abs(ball.vx) * 1.02;
        ball.vy = (ball.vy * 0.5) + (t * 260 * dpr);
        const maxSp = ball.baseSpeed * speedMul * dpr * 1.35;
        const curSp = Math.hypot(ball.vx, ball.vy);
        if (curSp > maxSp) { const m = maxSp / curSp; ball.vx *= m; ball.vy *= m; }
      }
    }

    if (performance.now() >= noScoreUntil) {
      const leftCross  = (ball.vx < 0) && ((oldX + r) >= 0) && ((ball.x + r) < 0);
      const rightCross = (ball.vx > 0) && ((oldX - r) <= W) && ((ball.x - r) > W);
      if (leftCross) { score('R'); return; }
      if (rightCross) { score('L'); return; }
    }

    const target = clamp(ball.y + (Math.random()*2-1)*aiNoise, paddle.h/2, H - paddle.h/2);
    const dy = target - aiY; const maxStep = aiSpeed * dt; aiY += clamp(dy, -maxStep, maxStep);

    playerY = clamp(playerY, paddle.h/2, H - paddle.h/2);
    aiY = clamp(aiY, paddle.h/2, H - paddle.h/2);

    draw();
  }

  function score(side){
    if (side === 'L') scoreL++; else scoreR++;
    scoreEl.textContent = scoreL + " : " + scoreR;
    scoreEl.classList.remove('bump'); void scoreEl.offsetWidth; scoreEl.classList.add('bump');
    resetBall(side === 'L' ? -1 : 1);
  }

  function loop(ts){
    const dt = Math.min(0.02, ((last===0? ts-16 : ts) - last)/1000 || 0.016);
    last = ts;
    if (!paused) step(dt);
    if (running) requestAnimationFrame(loop);
  }

  function start(){
    const sel = document.getElementById('speedMode');
    const v = sel ? sel.value : 'slow';
    speedMul = (v==='fast') ? 1.25 : (v==='normal') ? 1.0 : 0.75;
    aiSpeed = (v==='fast') ? 360*dpr : (v==='normal') ? 330*dpr : 300*dpr;

    scoreL=0; scoreR=0; scoreEl.textContent = "0 : 0";
    playerY = H/2; aiY = H/2;
    resetBall(Math.random()<0.5? -1 : 1);
    overlay.classList.add('hidden');
    paused=false; running=true; last=0;
    requestAnimationFrame(loop);
  }
  window.startGame = start;

  resize(); draw();
  </script>

<!-- Farcaster: hide splash once ready (Android-safe) -->
<script>
(function () {
  function tryReady() {
    try {
      if (window.__fc_sdk && window.__fc_sdk.actions && typeof window.__fc_sdk.actions.ready === 'function') { window.__fc_sdk.actions.ready(); return true; }
      if (window.farcaster && window.farcaster.sdk && window.farcaster.sdk.actions && typeof window.farcaster.sdk.actions.ready === 'function') { window.farcaster.sdk.actions.ready(); return true; }
      if (window.frame && window.frame.sdk && window.frame.sdk.actions && typeof window.frame.sdk.actions.ready === 'function') { window.frame.sdk.actions.ready(); return true; }
      if (window.sdk && window.sdk.actions && typeof window.sdk.actions.ready === 'function') { window.sdk.actions.ready(); return true; }
    } catch (e) {}
    return false;
  }
  if (!tryReady()) {
    let n = 0;
    const t = setInterval(() => { if (tryReady() || ++n > 50) clearInterval(t); }, 120); // retry ~6s max
  }
})();
</script>


  
</body>
</html>
