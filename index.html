<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>PicklePong Mini</title>

  <!-- Farcaster Frames + Mini App embed -->
  <meta property="fc:frame" content="vNext" />
  <meta property="fc:miniapp" content="vNext" />

  <!-- Open Graph (update if you change filenames) -->
  <meta property="og:title" content="PicklePong Mini" />
  <meta property="og:description" content="Retro pickleball Pong made for Farcaster Mini Apps." />
  <meta property="og:image" content="https://pong-miniapp.vercel.app/og.png" />
  <meta property="og:url" content="https://pong-miniapp.vercel.app/" />

  <!-- Premium retro look (CRT/scanlines), mobile-first, single-file build -->
  <style>
    :root{
      --bg:#0a0e14; /* deep retro */
      --court:#0fd976; /* pickleball neon */
      --accent:#f5e04c; /* pickleball ball */
      --text:#e6f1ff;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 50% 20%, #101622 0%, #070a10 70%, #05070b 100%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Apple Color Emoji,Segoe UI Emoji;}
    .wrap{position:fixed;inset:0;display:flex;flex-direction:column;}
    header{display:flex;align-items:center;justify-content:space-between;padding:.75rem 1rem;gap:.5rem;backdrop-filter:blur(6px);background:linear-gradient(180deg,rgba(15,217,118,.08),rgba(15,217,118,.02));border-bottom:1px solid rgba(15,217,118,.25);}
    header .brand{display:flex;align-items:center;gap:.65rem;font-weight:700;letter-spacing:.04em}
    .brand .dot{width:12px;height:12px;border-radius:50%;background:var(--accent);box-shadow:0 0 18px var(--accent);}
    .hud{display:flex;align-items:center;gap:.75rem;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid rgba(245,224,76,.6);background:rgba(245,224,76,.08);color:var(--text);padding:.45rem .7rem;border-radius:.8rem;font-weight:600;cursor:pointer;transition:.2s;}
    .btn:hover{background:rgba(245,224,76,.14)}
    .btn:active{transform:translateY(1px)}

    .crt{position:relative;flex:1;display:grid;place-items:center;overflow:hidden}
    canvas{max-width:100vw;max-height:calc(100vh - 110px);width:min(92vw,820px);aspect-ratio:10/16;background:linear-gradient(180deg,rgba(15,217,118,.08),transparent 20%), radial-gradient(400px 250px at 50% 0%, rgba(15,217,118,.18), transparent 55%), #0b0f15;border:1px solid rgba(15,217,118,.35);border-radius:22px;box-shadow:0 12px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.03);image-rendering:pixelated}
    /* scanlines */
    .crt:before{content:"";position:absolute;inset:0;background:repeating-linear-gradient( to bottom, rgba(0,0,0,.18) 0 2px, rgba(0,0,0,0) 2px 4px);mix-blend-mode:multiply;pointer-events:none}
    .crt:after{content:"";position:absolute;inset:-40% -20%;background:conic-gradient(from 180deg at 50% 10%, rgba(255,255,255,.08), rgba(255,255,255,0) 30% 70%, rgba(255,255,255,.08));filter:blur(40px);opacity:.4;pointer-events:none}

    footer{padding:.65rem 1rem;display:flex;align-items:center;justify-content:center;gap:1rem;font-size:.9rem;color:#a7b8cc;}
    .legend{opacity:.9}

    /* touch controls (optional) */
    .touchBar{position:fixed;inset:auto 0 0 0;height:80px;display:flex;align-items:center;justify-content:center;gap:16px;background:linear-gradient(180deg,transparent,rgba(7,10,16,.85));}
    .touchArea{flex:1;max-width:460px;height:52px;border-radius:999px;border:1px dashed rgba(15,217,118,.45);background:rgba(15,217,118,.06);display:flex;align-items:center;justify-content:center;color:#9edec1;font-weight:600;letter-spacing:.08em}

    @media (min-width: 780px){ .touchBar{display:none} }
  </style>

  <!-- Farcaster Mini App SDK via ESM CDN. Call ready() once UI is ready. -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    window.farcasterSDK = sdk; // optional: for debugging in console
    // We'll call sdk.actions.ready() after assets initialize in the game code.
  </script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand"><span class="dot"></span> PicklePong <small style="opacity:.7;font-weight:600">Mini</small></div>
      <div class="hud">
        <button id="btnPause" class="btn" title="Pause/Resume">‚è∏Ô∏è Pause</button>
        <button id="btnReset" class="btn" title="Reset">üîÑ Reset</button>
        <button id="btnSound" class="btn" title="Sound on/off">üîä Sound</button>
        <span id="score" aria-live="polite"></span>
      </div>
    </header>

    <div class="crt">
      <canvas id="game" width="540" height="864" aria-label="PicklePong game area" role="img"></canvas>
    </div>

    <footer>
      <span class="legend">Move your paddle: drag anywhere ¬∑ or arrow keys / W‚ÄìS</span>
    </footer>
  </div>

  <div class="touchBar">
    <div class="touchArea">Drag here to move</div>
  </div>

  <script>
  // ======= PicklePong ‚Äî retro pickleball-themed Pong (single file) =======
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Court
    const court = { w: W, h: H, pad: 24, line: 4, netGap: 12 };

    // Paddles
    const paddleW = 16, paddleH = 110, paddleR = 10;
    const player = { x: court.pad, y: H/2 - paddleH/2, w: paddleW, h: paddleH, vy: 0 };
    const cpu    = { x: W - court.pad - paddleW, y: H/2 - paddleH/2, w: paddleW, h: paddleH, vy: 0 };

    // Pickleball (perforated)
    const ball = { x: W/2, y: H/2, r: 12, vx: 5, vy: 2.5, maxSpeed: 12 };

    // Game state
    let running = true,
        playerScore = 0, cpuScore = 0,
        rally = 0,
        lastTime = performance.now();

    // Audio (simple blips)
    const audio = {
      on: true,
      hit: new Audio(), wall: new Audio(), score: new Audio()
    };
    // Tiny data URIs (placeholders so no external files needed)
    audio.hit.src   = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';
    audio.wall.src  = audio.hit.src;
    audio.score.src = audio.hit.src;

    const ui = {
      score: document.getElementById('score'),
      btnPause: document.getElementById('btnPause'),
      btnReset: document.getElementById('btnReset'),
      btnSound: document.getElementById('btnSound')
    };

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function randSign(){ return Math.random() < .5 ? -1 : 1; }

    function resetBall(dir = randSign()){
      ball.x = W/2; ball.y = H/2; rally = 0;
      const speed = 5.0; // base speed
      const angle = (Math.random()*.6 - .3); // launch variation
      ball.vx = speed * dir * Math.cos(angle);
      ball.vy = speed * Math.sin(angle);
    }

    function drawCourt(){
      // Outer glow
      ctx.save();
      ctx.shadowColor = 'rgba(15,217,118,.55)';
      ctx.shadowBlur = 18;

      // Court boundary
      ctx.strokeStyle = 'rgba(15,217,118,.9)';
      ctx.lineWidth = court.line;
      ctx.strokeRect(court.pad, court.pad, W - court.pad*2, H - court.pad*2);

      // Net (dashed)
      ctx.setLineDash([court.line*2, court.netGap]);
      ctx.beginPath();
      ctx.moveTo(W/2, court.pad);
      ctx.lineTo(W/2, H - court.pad);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.restore();
    }

    function drawPaddle(p){
      // Rounded rectangle paddle with subtle texture (pickleball paddle)
      const r = paddleR;
      const x = p.x, y = p.y, w = p.w, h = p.h;
      ctx.save();
      ctx.fillStyle = 'rgba(15,217,118,.15)';
      ctx.strokeStyle = 'rgba(15,217,118,.9)';
      ctx.lineWidth = 2;
      roundRect(ctx, x, y, w, h, r);
      ctx.fill();
      ctx.stroke();
      // Handle nub
      ctx.fillStyle = 'rgba(15,217,118,.35)';
      ctx.fillRect(x - 6 + (p===cpu?12:0), y + h/2 - 12, 12, 24);
      ctx.restore();
    }

    function drawBall(){
      // Perforated pickleball (accent color)
      const holes = 6;
      ctx.save();
      ctx.fillStyle = '#f5e04c';
      ctx.shadowColor = 'rgba(245,224,76,.55)';
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,.22)';
      for(let i=0;i<holes;i++){
        const a = (i/holes) * Math.PI*2;
        const hx = ball.x + Math.cos(a)*ball.r*.55;
        const hy = ball.y + Math.sin(a)*ball.r*.4;
        ctx.beginPath();
        ctx.arc(hx, hy, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function roundRect(c, x, y, w, h, r){
      c.beginPath();
      c.moveTo(x+r, y);
      c.arcTo(x+w, y, x+w, y+h, r);
      c.arcTo(x+w, y+h, x, y+h, r);
      c.arcTo(x, y+h, x, y, r);
      c.arcTo(x, y, x+w, y, r);
      c.closePath();
    }

    function update(){
      if(!running) return;

      // Move ball
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Wall collisions
      if(ball.y - ball.r < court.pad){ ball.y = court.pad + ball.r; ball.vy *= -1; play(audio.wall); }
      if(ball.y + ball.r > H - court.pad){ ball.y = H - court.pad - ball.r; ball.vy *= -1; play(audio.wall); }

      // Paddle collisions
      function collide(p){
        if(ball.x - ball.r < p.x + p.w && ball.x + ball.r > p.x && ball.y + ball.r > p.y && ball.y - ball.r < p.y + p.h){
          // reflect, with angle based on impact point
          const rel = (ball.y - (p.y + p.h/2)) / (p.h/2);
          const speed = Math.min(Math.hypot(ball.vx, ball.vy)*1.06 + .2*rally, ball.maxSpeed);
          const dir = p === player ? 1 : -1; // ball moves to opponent
          const angle = rel * 0.7; // control spin/deflection
          ball.vx = speed * dir * Math.cos(angle);
          ball.vy = speed * Math.sin(angle);
          ball.x = p === player ? p.x + p.w + ball.r + 0.5 : p.x - ball.r - 0.5;
          rally++;
          play(audio.hit);
        }
      }
      collide(player); collide(cpu);

      // Score check
      if(ball.x < 0){ cpuScore++; resetBall(1); play(audio.score); }
      if(ball.x > W){ playerScore++; resetBall(-1); play(audio.score); }

      // CPU AI ‚Äî tracks ball with easing and prediction
      const target = ball.y - cpu.h/2 + clamp((ball.vy*12), -80, 80);
      cpu.y += clamp(target - cpu.y, - (2.4 + rally*0.05), (2.4 + rally*0.05));
      cpu.y = clamp(cpu.y, court.pad, H - court.pad - cpu.h);

      // Player motion already handled via input; clamp
      player.y = clamp(player.y, court.pad, H - court.pad - player.h);

      ui.score.textContent = `üèì ${playerScore} : ${cpuScore}`;
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawCourt();
      drawPaddle(player);
      drawPaddle(cpu);
      drawBall();

      // Glow trail (subtle)
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(15,217,118,.06)';
      ctx.beginPath();
      ctx.arc(ball.x - ball.vx*1.2, ball.y - ball.vy*1.2, ball.r*1.25, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function loop(t){
      const dt = Math.min((t - lastTime)/16.666, 2);
      lastTime = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Input ‚Äî mouse/touch drag anywhere to move player's paddle
    const drag = { active:false, oy:0, py:0 };

    function pointerY(e){ return (e.touches? e.touches[0].clientY : e.clientY) - canvas.getBoundingClientRect().top; }

    function startDrag(e){ drag.active = true; drag.oy = pointerY(e); drag.py = player.y; }
    function moveDrag(e){ if(!drag.active) return; const dy = pointerY(e) - drag.oy; player.y = drag.py + dy; }
    function endDrag(){ drag.active=false; }

    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);

    canvas.addEventListener('touchstart', (e)=>{ startDrag(e); }, {passive:true});
    canvas.addEventListener('touchmove',  (e)=>{ moveDrag(e);  }, {passive:true});
    canvas.addEventListener('touchend',   endDrag, {passive:true});

    // Keyboard (optional)
    window.addEventListener('keydown', (e)=>{
      if(e.key==='ArrowUp' || e.key==='w') player.y -= 28;
      if(e.key==='ArrowDown' || e.key==='s') player.y += 28;
      if(e.key===' ') { running=!running; ui.btnPause.textContent = running? '‚è∏Ô∏è Pause':'‚ñ∂Ô∏è Resume'; }
    });

    // UI buttons
    ui.btnPause.addEventListener('click', ()=>{ running=!running; ui.btnPause.textContent = running? '‚è∏Ô∏è Pause':'‚ñ∂Ô∏è Resume'; });
    ui.btnReset.addEventListener('click', ()=>{ playerScore=0; cpuScore=0; resetBall(randSign()); running=true; ui.btnPause.textContent='‚è∏Ô∏è Pause'; });
    ui.btnSound.addEventListener('click', ()=>{ audio.on=!audio.on; ui.btnSound.textContent = audio.on? 'üîä Sound':'üîà Muted'; });

    function play(a){ if(audio.on){ try{ a.currentTime=0; a.play(); }catch{} } }

    // Initialize
    resetBall(randSign());
    requestAnimationFrame(loop);

    // Signal Farcaster we're ready (hide splash)
    (async () => { try{ if(window.farcasterSDK){ await window.farcasterSDK.actions.ready(); } } catch(e){ /* non-miniapp env */ } })();
  })();
  </script>

  <!--
  ========================
  Mini App manifest (already hosted by you at /.well-known/farcaster.json)
  Keep it in sync with these values:

  {
    "name": "PicklePong Mini",
    "description": "Retro pickleball Pong made for Farcaster Mini Apps.",
    "icon_url": "https://pong-miniapp.vercel.app/icon.png",
    "home_url": "https://pong-miniapp.vercel.app/",
    "contact": { "website": "https://pong-miniapp.vercel.app/" }
  }
  ========================
  -->
</body>
</html>
