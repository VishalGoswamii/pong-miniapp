<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Pickle Pong ‚Äî Farcaster Mini App</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

  <!-- Farcaster Mini App Embed -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://pong-miniapp.vercel.app/og-1200x800.png",
    "button":{
      "title":"Play Pickle Pong",
      "action":{
        "type":"launch_frame",
        "name":"Pickle Pong",
        "url":"https://pong-miniapp.vercel.app/",
        "splashImageUrl":"https://pong-miniapp.vercel.app/icon-200.png",
        "splashBackgroundColor":"#0a2b19"
      }
    }
  }'/>
  <meta name="fc:frame" content='{
    "version":"1",
    "imageUrl":"https://pong-miniapp.vercel.app/og-1200x800.png",
    "button":{
      "title":"Play Pickle Pong",
      "action":{
        "type":"launch_frame",
        "name":"Pickle Pong",
        "url":"https://pong-miniapp.vercel.app/",
        "splashImageUrl":"https://pong-miniapp.vercel.app/icon-200.png",
        "splashBackgroundColor":"#0a2b19"
      }
    }
  }'/>

  <style>
    :root{
      --court-a:#135b2e;   /* gradient top */
      --court-b:#0b3c22;   /* gradient bottom */
      --net:#e5e7eb;
      --lines:#ffffff;
      --kitchen:#0f4c81;
      --ball:#f9f871;
      --paddleL:#1f2937; --paddleL-ac:#34d399;
      --paddleR:#374151; --paddleR-ac:#60a5fa;
      --hud:#e5e7eb;
      --plate:#0b1a12cc;
      --plate-border:#1f3a2f;
      --btn:#10271b; --btn-border:#214a36; --btn-text:#e6f0ea;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--court-a),var(--court-b));color:var(--lines)}
    .wrap{position:fixed;inset:env(safe-area-inset-top,0) 0 env(safe-area-inset-bottom,0) 0;display:grid;place-items:center;contain:strict}
    canvas{width:min(100vw,100vh);height:min(100vw,100vh);display:block;background:transparent}

    /* scoreplates */
    .plates{position:fixed;inset:10px 0 auto 0;display:flex;justify-content:space-between;gap:8px;padding:0 12%;pointer-events:none}
    .plate{background:var(--plate);border:1px solid var(--plate-border);backdrop-filter:blur(6px);padding:6px 14px;border-radius:14px;font:900 56px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;box-shadow:0 6px 22px rgba(0,0,0,.25)}
    .hud{position:fixed;left:0;right:0;top:72px;text-align:center;font:600 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:var(--hud);pointer-events:none}

    /* postgame overlay (only visible when game over / paused) */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,.25),rgba(0,0,0,.55));backdrop-filter:blur(6px)}
    .overlay.show{display:flex}
    .card{width:min(92vw,460px);background:#0d1b14;border:1px solid #1f3a2f;border-radius:16px;padding:20px;box-shadow:0 12px 40px rgba(0,0,0,.45);color:#e6f0ea;font:600 14px/1.3 system-ui}
    .card h1{margin:0 0 8px 0;font:900 26px/1.1 system-ui}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .btn{appearance:none;border:1px solid var(--btn-border);background:var(--btn);color:var(--btn-text);border-radius:12px;padding:10px 14px;font:700 14px/1 system-ui;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .ghost{background:transparent}
    .fine{opacity:.85}

    /* pause chip */
    .pause{position:fixed;left:12px;bottom:14px;display:inline-flex;align-items:center;gap:8px;background:var(--plate);border:1px solid var(--plate-border);border-radius:999px;padding:8px 12px;font:700 12px/1 system-ui;color:#d8e7dc}
  </style>

  <!-- Farcaster SDK -->
  <script defer src="https://cdn.jsdelivr.net/npm/@farcaster/miniapp-sdk/dist/index.umd.js"></script>
</head>
<body>
  <div class="wrap">
    <canvas id="game" aria-label="Pickle Pong"></canvas>
  </div>

  <!-- Scores & HUD -->
  <div class="plates"><div id="scoreL" class="plate">0</div><div id="scoreR" class="plate">0</div></div>
  <div id="hud" class="hud"></div>

  <!-- Pause chip -->
  <button id="pauseBtn" class="pause" aria-label="Pause/Resume">‚èØ Pause</button>

  <!-- Post-game / menu overlay -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="card">
      <h1 id="ovTitle">Game Over</h1>
      <div class="fine" id="ovSubtitle">Final score ‚Ä¢ <span id="ovL">0</span>‚Äì<span id="ovR">0</span></div>
      <div class="row">
        <button id="restartBtn" class="btn">‚ñ∂ Play Again</button>
        <button id="addBtn" class="btn">‚ûï Add to Farcaster</button>
        <button id="shareBtn" class="btn">üì£ Share High Score</button>
        <button id="closeBtn" class="btn ghost">‚úï Close</button>
      </div>
      <div class="fine" style="margin-top:10px">Tip: first to 11 wins. Use arrow keys or drag to move.</div>
    </div>
  </div>

<script>
(function(){
  'use strict';

  /* -------- Farcaster SDK (robust) -------- */
  let fc=null, readySent=false;
  function setupSDK(){
    if(window.FarcasterMiniApp && !fc){
      fc = new window.FarcasterMiniApp.MiniAppSDK();
      // Wait to send ready until after first paint (we call in draw()).
      fc.context().catch(()=>{});
    }
  }
  document.addEventListener('DOMContentLoaded', setupSDK);
  function signalReady(){
    if(readySent) return;
    readySent=true;
    if(fc){ try{ fc.actions.ready(); }catch(e){} }
  }

  /* -------- DOM refs -------- */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha:false, desynchronized:true});
  const hud = document.getElementById('hud');
  const scoreL = document.getElementById('scoreL');
  const scoreR = document.getElementById('scoreR');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovSubtitle = document.getElementById('ovSubtitle');
  const ovL = document.getElementById('ovL');
  const ovR = document.getElementById('ovR');
  const restartBtn = document.getElementById('restartBtn');
  const addBtn = document.getElementById('addBtn');
  const shareBtn = document.getElementById('shareBtn');
  const closeBtn = document.getElementById('closeBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  /* -------- Config tuned for smaller paddles & faster feel -------- */
  const WIN_SCORE = 11;
  const DPR_MIN=1, DPR_MAX=2, FIXED_DT=1/60, MAX_ACCUM=0.25;
  const BALL=12;
  const SPEED_BALL=250, SPEED_AI=330, SPEED_PADDLE=380;

  // Smaller paddles: ~1.3% width; ~38% height (feels nimble)
  let P_W=0, P_H=0, P_R=0, DOT_H=0, DOT_G=0;

  const state={
    dpr:1, cssW:0, cssH:0, last:0, accum:0,
    lY:0, rY:0,
    scoreL:0, scoreR:0, rally:0,
    counting:true, t0:0,
    paused:false, gameover:false,
    effects:{grow:0,shield:0,slowmo:0,multiball:0,x2:0},
    powerups:[],
    balls:[],
    sparks:[]
  };

  /* -------- Utils -------- */
  function clamp(v,a,b){ return v<a?a : v>b?b : v; }
  function sizeCanvas(){
    const r=canvas.getBoundingClientRect();
    const dpr=clamp(window.devicePixelRatio||1, DPR_MIN, DPR_MAX);
    if(state.cssW===r.width && state.cssH===r.height && state.dpr===dpr) return;
    state.cssW=r.width|0; state.cssH=r.height|0; state.dpr=dpr;
    canvas.width=Math.max(1,Math.floor(state.cssW*dpr));
    canvas.height=Math.max(1,Math.floor(state.cssH*dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled=false;

    P_W = Math.max(10, Math.round(state.cssW*0.013));  // thinner
    P_H = Math.max(120, Math.round(state.cssH*0.38));  // shorter
    P_R = Math.round(P_W*0.45);
    DOT_H = Math.max(6, Math.round(state.cssH*0.012));
    DOT_G = DOT_H;
  }

  function spawnBall(dir){
    const ay=clamp(Math.random()*2-1,-0.75,0.75);
    const s=SPEED_BALL*(1+state.rally*0.012);
    const vx=dir*s*Math.sqrt(1-ay*ay), vy=s*ay;
    state.balls=[{x:(state.cssW-BALL)/2,y:(state.cssH-BALL)/2,vx,vy}];
  }

  function resetRound(dir){
    state.rally=0;
    state.counting=true; state.t0=performance.now();
    spawnBall(dir);
  }
  function hardReset(){
    state.scoreL=0; state.scoreR=0; state.rally=0;
    state.gameover=false; state.paused=false;
    hideOverlay();
    state.lY=(state.cssH-P_H)/2;
    state.rY=(state.cssH-P_H)/2;
    resetRound(Math.random()<0.5?-1:1);
    updateHUD();
  }
  function updateHUD(){
    scoreL.textContent = state.scoreL;
    scoreR.textContent = state.scoreR;
    hud.textContent = state.paused ? 'Paused' : `Rally: ${state.rally}`;
  }

  /* -------- Power-ups (unchanged behavior, but spawn a tad slower) -------- */
  function addPowerup(){
    const kinds=['grow','shield','slowmo','multiball','x2'];
    const t=kinds[(Math.random()*kinds.length)|0];
    const x=clamp(Math.random()*state.cssW, state.cssW*0.25, state.cssW*0.75);
    const y=clamp(Math.random()*state.cssH, 40, state.cssH-40);
    state.powerups.push({t,x,y,ttl:8});
  }
  let nextPU=3.0;
  function puTick(dt){
    nextPU-=dt;
    if(nextPU<=0 && !state.counting && !state.paused && !state.gameover){
      addPowerup(); nextPU=4.5+Math.random()*3.5;
    }
    for(let i=state.powerups.length-1;i>=0;i--){
      const pu=state.powerups[i]; pu.ttl-=dt; if(pu.ttl<=0) state.powerups.splice(i,1);
    }
    for(const k in state.effects){ if(state.effects[k]>0) state.effects[k]-=dt; }
  }
  function activate(t){
    if(t==='grow') state.effects.grow=6;
    if(t==='shield') state.effects.shield=999;
    if(t==='slowmo') state.effects.slowmo=5;
    if(t==='multiball'){ state.effects.multiball=8;
      if(state.balls.length<3){
        const b=state.balls[0];
        state.balls.push({x:b.x,y:b.y,vx:-b.vx*1.05,vy:b.vy*0.8});
        state.balls.push({x:b.x,y:b.y,vx:b.vx*0.8,vy:-b.vy*1.05});
      }
    }
    if(t==='x2'){ state.effects.x2=10; }
  }

  /* -------- Simulation -------- */
  const keys={up:false,down:false}; let pointerY=null;
  function stepBall(b,dt){
    b.x+=b.vx*dt; b.y+=b.vy*dt;
    if(b.y<=0){ b.y=0; b.vy=Math.abs(b.vy); }
    else if(b.y+BALL>=state.cssH){ b.y=state.cssH-BALL; b.vy=-Math.abs(b.vy); }

    const growK=state.effects.grow>0?1.5:1, pH=P_H*growK;

    // left collide
    if(b.x<=P_W+16){
      if(b.y+BALL>=state.lY && b.y<=state.lY+pH){
        b.x=P_W+16; b.vx=Math.abs(b.vx)*1.045;
        const rel=((b.y+BALL/2)-(state.lY+pH/2))/(pH/2);
        b.vy+=rel*92; state.rally++;
      }
    }
    // right collide
    const rx=state.cssW-(P_W+16)-BALL;
    if(b.x>=rx){
      if(b.y+BALL>=state.rY && b.y<=state.rY+pH){
        b.x=rx; b.vx=-Math.abs(b.vx)*1.045;
        const rel=((b.y+BALL/2)-(state.rY+pH/2))/(pH/2);
        b.vy+=rel*92; state.rally++;
      }
    }

    // score
    if(b.x+BALL<0){
      if(state.effects.shield>0){ state.effects.shield=0; b.x=0; b.vx=Math.abs(b.vx); }
      else { state.scoreR++; resetRound(+1); checkWin(); }
    } else if(b.x>state.cssW){
      const add=(state.effects.x2>0?2:1);
      state.scoreL+=add; resetRound(-1); checkWin();
    }
  }

  function step(dt){
    if(state.paused || state.gameover) return;
    if(state.counting) return;

    const pH=P_H*(state.effects.grow>0?1.5:1);
    if(keys.up) state.lY-=SPEED_PADDLE*dt;
    if(keys.down) state.lY+=SPEED_PADDLE*dt;
    if(pointerY!=null){
      const rect=canvas.getBoundingClientRect();
      const y=(pointerY-rect.top)*(state.cssH/rect.height)-pH/2;
      const dy=clamp(y,0,state.cssH-pH)-state.lY;
      state.lY+=clamp(dy,-SPEED_PADDLE*dt,SPEED_PADDLE*dt);
    }
    state.lY=clamp(state.lY,0,state.cssH-pH);

    // AI: slightly imperfect tracking (fun)
    const avgY = state.balls.reduce((s,b)=>s+b.y,0)/state.balls.length;
    const target = avgY + BALL/2 - pH/2 + Math.sin(performance.now()/270)*8;
    const dy = target - state.rY;
    state.rY = clamp(state.rY + clamp(dy, -SPEED_AI*dt, SPEED_AI*dt), 0, state.cssH-pH);

    puTick(dt);

    // pickups (player side)
    for(let i=state.powerups.length-1;i>=0;i--){
      const pu=state.powerups[i];
      if(pu.x>10 && pu.x<state.cssW*0.5 && pu.y>state.lY-8 && pu.y<state.lY+pH+8){
        activate(pu.t); state.powerups.splice(i,1);
      }
    }

    const slow = state.effects.slowmo>0 ? 0.6 : 1;
    const worldDt=dt*slow;
    for(const b of state.balls) stepBall(b,worldDt);
  }

  function checkWin(){
    updateHUD();
    if(state.scoreL>=WIN_SCORE || state.scoreR>=WIN_SCORE){
      state.gameover=true;
      showOverlay('Game Over', state.scoreL, state.scoreR);
      // save high score
      const hs = Number(localStorage.getItem('pickle_high')||0);
      if(state.scoreL>hs){ localStorage.setItem('pickle_high', String(state.scoreL)); }
    }
  }

  /* -------- Drawing (pickleball court + nicer UI) -------- */
  function roundedRect(x,y,w,h,r){
    const rr=Math.min(r,Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawCourt(w,h){
    // gradient background already via CSS; add court lines + net
    // border
    ctx.strokeStyle='rgba(255,255,255,.9)';
    ctx.lineWidth=2; ctx.strokeRect(8,8,w-16,h-16);
    // kitchen band
    ctx.fillStyle='rgba(15,76,129,0.35)';
    ctx.fillRect(0, h/2 - h*0.12, w, h*0.24);
    // center service lines
    ctx.beginPath();
    ctx.moveTo(w/2, 8); ctx.lineTo(w/2, h/2 - h*0.12);
    ctx.moveTo(w/2, h/2 + h*0.12); ctx.lineTo(w/2, h-8);
    ctx.stroke();

    // dotted net with subtle shimmer
    const y=(h/2|0)-1;
    const phase = (performance.now()/300)%1;
    for(let x=0;x<w;x+=10){
      const a=0.6+0.4*Math.abs(Math.sin((x/w+phase)*Math.PI));
      ctx.fillStyle=`rgba(229,231,235,${a.toFixed(2)})`;
      ctx.fillRect(x, y, 6, 2);
    }
  }
  function drawPaddle(x,y,w,h,isLeft){
    const handleH=Math.max(24,Math.round(h*0.18));
    const handleW=Math.round(w*0.6);
    const handleX=x+(w-handleW)/2;
    const handleY=y+h-handleH-4;

    ctx.save();
    ctx.shadowColor='rgba(0,0,0,.3)'; ctx.shadowBlur=8;
    ctx.fillStyle=isLeft?'#1f2937':'#374151';
    roundedRect(x,y,w,h-handleH+6,Math.round(w*0.45)); ctx.fill();
    ctx.fillStyle=isLeft?'#34d399':'#60a5fa';
    roundedRect(handleX,handleY,handleW,handleH,Math.round(handleW*0.3)); ctx.fill();
    ctx.restore();

    // subtle dots
    ctx.fillStyle='rgba(255,255,255,0.06)';
    for(let yy=y+10; yy<y+h-handleH-10; yy+=12){
      for(let xx=x+6; xx<x+w-6; xx+=10){
        ctx.beginPath(); ctx.arc(xx,yy,1.1,0,Math.PI*2); ctx.fill();
      }
    }
  }
  function drawBall(x,y){
    const r=BALL*0.65, cx=x+BALL/2, cy=y+BALL/2;
    const g=ctx.createRadialGradient(cx,cy,0,cx,cy,r*1.8);
    g.addColorStop(0,'rgba(249,248,113,1)');
    g.addColorStop(0.6,'rgba(249,248,113,0.45)');
    g.addColorStop(1,'rgba(249,248,113,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r*1.6,0,Math.PI*2); ctx.fill();

    ctx.fillStyle='#f9f871'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

    // holes
    ctx.fillStyle='rgba(0,0,0,0.25)';
    const holes=8, ring=r*0.55;
    for(let i=0;i<holes;i++){
      const ang=i/holes*Math.PI*2, hx=cx+Math.cos(ang)*ring, hy=cy+Math.sin(ang)*ring;
      ctx.beginPath(); ctx.arc(hx,hy,r*0.14,0,Math.PI*2); ctx.fill();
    }
  }
  function draw(){
    const w=state.cssW, h=state.cssH;
    drawCourt(w,h);

    const growK=state.effects.grow>0?1.5:1, pH=P_H*growK;
    drawPaddle(16, state.lY, P_W, pH, true);
    drawPaddle(w-P_W-16, state.rY, P_W, pH, false);

    // power-ups (coins)
    for(const pu of state.powerups){
      ctx.save(); ctx.translate(pu.x, pu.y); ctx.globalAlpha=.95;
      ctx.fillStyle='#0f172a'; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=2; ctx.stroke();
      ctx.font='700 12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#e5e7eb';
      ctx.fillText(({grow:'‚¨Ü',shield:'üõ°',slowmo:'‚è±',multiball:'‚ú¶',x2:'x2'})[pu.t]||'?',0,1);
      ctx.restore();
    }

    // balls
    for(const b of state.balls) drawBall(b.x,b.y);

    // countdown
    if(state.counting){
      const el=(performance.now()-state.t0)/1000;
      const rem=Math.max(0,3-Math.floor(el));
      if(rem>0){
        ctx.font='900 64px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
        ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#f9f871';
        ctx.globalAlpha=.95;
        const frac=1-(el%1), s=1+0.2*(1-frac);
        ctx.save(); ctx.translate(w/2,h/2); ctx.scale(s,s); ctx.fillText(String(rem),0,0); ctx.restore();
        ctx.globalAlpha=1;
      } else state.counting=false;
    }

    // update HUD plates
    scoreL.textContent = state.scoreL;
    scoreR.textContent = state.scoreR;
    hud.textContent = state.paused ? 'Paused' : `Rally: ${state.rally}`;

    // tell host we're ready after first paint
    signalReady();
  }

  /* -------- Loop -------- */
  function loop(ts){
    if(!state.last) state.last=ts;
    let dt=(ts-state.last)/1000; state.last=ts;

    if(!state.paused && !state.gameover){
      state.accum=Math.min(MAX_ACCUM, state.accum+dt);
      while(state.accum>=FIXED_DT){
        step(FIXED_DT);
        state.accum-=FIXED_DT;
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  /* -------- Buttons & overlay logic -------- */
  function showOverlay(title,l,r){
    ovTitle.textContent = title;
    ovL.textContent = l; ovR.textContent = r;
    overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false');
  }
  function hideOverlay(){
    overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true');
  }

  restartBtn.onclick = ()=>{ hardReset(); };
  closeBtn.onclick = ()=>{ hideOverlay(); state.paused=false; };
  pauseBtn.onclick = ()=>{
    state.paused=!state.paused;
    if(state.paused){ showOverlay('Paused', state.scoreL, state.scoreR); }
    else { hideOverlay(); }
  };

  addBtn.onclick = async ()=>{
    if(fc){ try{ await fc.actions.addMiniApp(); return; }catch(e){} }
    // fallback: open your URL
    window.open('https://pong-miniapp.vercel.app/','_blank');
  };

  shareBtn.onclick = async ()=>{
    const hs = Number(localStorage.getItem('pickle_high')||0);
    const text = `I just hit ${hs} in Pickle Pong! ü•íüèì https://pong-miniapp.vercel.app/`;
    if(fc){ try{ await fc.actions.composeCast({ text }); return; }catch(e){} }
    if(navigator.share){ try{ await navigator.share({ text }); return; }catch(e){} }
    // fallback: copy
    try{
      await navigator.clipboard.writeText(text);
      shareBtn.textContent='‚úÖ Copied!';
      setTimeout(()=>shareBtn.textContent='üì£ Share High Score',1600);
    }catch(_){}
  };

  /* -------- Input -------- */
  function onKey(e){ const d=e.type==='keydown';
    if(e.key==='ArrowUp'||e.key==='w'||e.key==='W'){ keys.up=d; e.preventDefault(); }
    if(e.key==='ArrowDown'||e.key==='s'||e.key==='S'){ keys.down=d; e.preventDefault(); }
    if(e.key==='Escape'){ if(!state.gameover) pauseBtn.click(); }
  }
  window.addEventListener('keydown',onKey,{passive:false});
  window.addEventListener('keyup',onKey,{passive:false});
  canvas.addEventListener('pointerdown',e=>{ pointerY=e.clientY; },{passive:true});
  window.addEventListener('pointermove',e=>{ if(pointerY!=null) pointerY=e.clientY; },{passive:true});
  window.addEventListener('pointerup',()=>{ pointerY=null; },{passive:true});

  window.addEventListener('resize',sizeCanvas,{passive:true});
  document.addEventListener('visibilitychange',()=>{ state.last=0; });

  /* -------- Init -------- */
  function init(){ sizeCanvas(); state.lY=(state.cssH-P_H)/2; state.rY=(state.cssH-P_H)/2; resetRound(Math.random()<0.5?-1:1); requestAnimationFrame(loop); }
  init();

})();
</script>
</body>
</html>
