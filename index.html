<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <title>PicklePong Mini</title>

  <style>
    :root{
      --text:#e6f1ff;
      --accent:#f5e04c;
      --btn-bg: rgba(245,224,76,.10);
      --btn-border: rgba(245,224,76,.65);
      --btn-bg-strong: rgba(245,224,76,.22);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    html,body{height:100%;margin:0;background:#070a10;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}

    /* Router */
    .view{display:none}
    .homeWrap.view.show, .gameWrap.view.show, .page.view.show{display:flex}

    /* Mobile layout */
    .homeWrap{min-height:100dvh;flex-direction:column;align-items:center;justify-content:center;padding:16px 14px 28px;gap:10px}
    .gameWrap{min-height:100dvh;flex-direction:column}
    .page{min-height:100dvh;flex-direction:column}

    /* Buttons: big, stacked */
    .btn{
      display:block; width:min(92vw,520px);
      padding:14px 16px; margin:8px auto;
      border-radius:16px; font-weight:800; letter-spacing:.02em;
      background:var(--btn-bg); border:1px solid var(--btn-border); color:var(--text);
      box-shadow:var(--shadow);
    }
    .btn.primary{ background:var(--btn-bg-strong) }
    .btn.chip{
      width:auto; padding:10px 12px; margin:0; border-radius:12px;
      display:inline-block; box-shadow:none;
    }

    .bar{display:flex; align-items:center; gap:8px; flex-wrap:wrap; padding:10px 12px}
    .spacer{flex:1}

    /* Game area */
    .crt{display:grid;place-items:center;position:relative;padding:12px 0}
    canvas{
      border-radius:12px;border:2px solid #333;
      width:min(92vw, 360px); height:auto; aspect-ratio:2/3;
      image-rendering:pixelated;
      box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04);
      background:#0b0f15; /* overdrawn by court painter */
    }

    /* Countdown perfectly overlays the canvas size */
    .countdown{
      position:absolute; display:none; place-items:center; background:rgba(0,0,0,.55);
      border-radius:12px; inset:auto; width:min(92vw, 360px); aspect-ratio:2/3; place-self:center
    }
    .countdown.show{display:grid !important}
    .countNum{font-size:3.6rem; font-weight:1000; letter-spacing:.06em; color:var(--accent); text-shadow:0 0 18px rgba(245,224,76,.5)}

    /* Cards for settings/board */
    .card{margin:8px auto; width:min(92vw,560px); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:14px 12px; box-shadow:var(--shadow)}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .list{margin:0; padding-left:18px}
  </style>
</head>
<body>
  <!-- HOME -->
  <div id="homePage" class="homeWrap view show">
    <main style="text-align:center;width:100%">
      <h1 style="margin:0 0 4px">üèì PicklePong</h1>
      <div style="opacity:.8;margin-bottom:8px">Mobile-only ‚Ä¢ Farcaster-friendly</div>

      <button id="playRegular" class="btn primary">‚ñ∂Ô∏è Play ‚Äî Regular</button>
      <button id="playArcade"  class="btn">‚ö° Play ‚Äî Arcade (Power-ups)</button>
      <button id="btnShare"    class="btn">üîó Share</button>
      <button id="btnSettings" class="btn">‚öôÔ∏è Settings</button>
      <button id="btnBoard"    class="btn">üèÜ Leaderboard</button>
    </main>
  </div>

  <!-- GAME -->
  <div id="gamePage" class="gameWrap view">
    <header class="bar">
      <button id="btnHome"  class="btn chip">üè† Home</button>
      <button id="btnPause" class="btn chip">‚è∏Ô∏è Pause</button>
      <button id="btnReset" class="btn chip">üîÑ Reset</button>
      <button id="btnTheme" class="btn chip" title="Toggle court theme">üé® Theme: Blue|Red</button>
      <span class="spacer"></span>
      <span id="modeTag"  class="btn chip" style="pointer-events:none"></span>
      <span id="score"    class="btn chip" style="pointer-events:none; min-width:60px; text-align:center"></span>
    </header>

    <div class="crt">
      <canvas id="game" width="540" height="810" aria-label="PicklePong game area" role="img"></canvas>
      <section id="countdown" class="countdown"><div id="countNum" class="countNum">3</div></section>
    </div>
  </div>

  <!-- SETTINGS -->
  <div id="settingsPage" class="page view" style="padding:10px 12px 24px">
    <header class="bar">
      <strong>Settings</strong>
      <span class="spacer"></span>
      <button id="backFromSettings" class="btn chip">‚¨ÖÔ∏è Back</button>
    </header>
    <main class="card">
      <div class="row" style="margin-bottom:10px">
        <label><b>Sound</b></label>
        <button id="toggleSound" class="btn chip">üîä On</button>
      </div>
      <div class="row">
        <label><b>Court Theme</b></label>
        <button id="setBlueRed" class="btn chip">Blue | Red</button>
        <button id="setRedBlue" class="btn chip">Red | Blue</button>
      </div>
      <div style="opacity:.7;margin-top:8px">Theme format is <i>Left | Right</i> ground color.</div>
    </main>
  </div>

  <!-- LEADERBOARD -->
  <div id="boardPage" class="page view" style="padding:10px 12px 24px">
    <header class="bar">
      <strong>Leaderboard</strong>
      <span class="spacer"></span>
      <button id="clearBoard" class="btn chip">üßπ Clear</button>
      <button id="backFromBoard" class="btn chip">‚¨ÖÔ∏è Back</button>
    </header>
    <main class="card">
      <ol id="boardList" class="list"></ol>
    </main>
  </div>

  <script>
  (function(){
    /* ===== Router ===== */
    const views = {
      home: document.getElementById('homePage'),
      game: document.getElementById('gamePage'),
      settings: document.getElementById('settingsPage'),
      board: document.getElementById('boardPage')
    };
    function show(id){ Object.values(views).forEach(v=>v.classList.remove('show')); views[id].classList.add('show'); }

    /* ===== DOM ===== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const scoreEl = document.getElementById('score');
    const modeTag = document.getElementById('modeTag');
    const countdown = document.getElementById('countdown');
    const countNum  = document.getElementById('countNum');
    const btnTheme  = document.getElementById('btnTheme');

    // Home
    document.getElementById('playRegular').onclick = ()=>{ mode='regular'; modeTag.textContent='REGULAR'; startGame(); };
    document.getElementById('playArcade').onclick  = ()=>{ mode='arcade';  modeTag.textContent='ARCADE';  startGame(); };
    document.getElementById('btnShare').onclick = async ()=>{
      try { if(navigator.share){ await navigator.share({ url: location.href, text: 'Play PicklePong Mini!' }); }
            else { await navigator.clipboard.writeText(location.href); alert('Link copied!'); } }
      catch(e){ try{ await navigator.clipboard.writeText(location.href); alert('Link copied!'); }catch{} }
    };
    document.getElementById('btnSettings').onclick = ()=> show('settings');
    document.getElementById('btnBoard').onclick    = ()=>{ renderBoard(); show('board'); };

    // Game header
    document.getElementById('btnHome').onclick  = ()=>{ running=false; show('home'); };
    document.getElementById('btnPause').onclick = ()=>{ if(!counting){ running=!running; } };
    document.getElementById('btnReset').onclick = ()=>{ if(!counting){ playerScore=cpuScore=0; resetRound(randSign()); running=false; startCountdown(()=>{ running=true; }); } };
    btnTheme.onclick = ()=>{
      themeLR = (themeLR==='blue|red') ? 'red|blue' : 'blue|red';
      btnTheme.textContent = 'üé® Theme: ' + (themeLR==='blue|red'?'Blue|Red':'Red|Blue');
      saveSettings();
    };

    // Settings page
    document.getElementById('backFromSettings').onclick = ()=> show('home');
    const toggleSoundBtn = document.getElementById('toggleSound');
    toggleSoundBtn.onclick = ()=>{ settings.sound=!settings.sound; syncSettingsUI(); saveSettings(); };
    document.getElementById('setBlueRed').onclick = ()=>{ themeLR='blue|red';  btnTheme.textContent='üé® Theme: Blue|Red'; saveSettings(); };
    document.getElementById('setRedBlue').onclick = ()=>{ themeLR='red|blue';   btnTheme.textContent='üé® Theme: Red|Blue'; saveSettings(); };

    // Board page
    document.getElementById('clearBoard').onclick = ()=>{ localStorage.removeItem('pp_board'); board.length=0; renderBoard(); };
    document.getElementById('backFromBoard').onclick = ()=> show('home');

    /* ===== Settings / Persistence ===== */
    const saved = JSON.parse(localStorage.getItem('pp_settings')||'{}');
    const settings = { sound: saved.sound !== undefined ? saved.sound : true };
    let themeLR = saved.themeLR || 'blue|red'; // "left|right"
    function saveSettings(){ localStorage.setItem('pp_settings', JSON.stringify({ ...settings, themeLR })); }
    function syncSettingsUI(){ toggleSoundBtn.textContent = settings.sound ? 'üîä On' : 'üîà Off'; }
    syncSettingsUI(); btnTheme.textContent = 'üé® Theme: ' + (themeLR==='blue|red'?'Blue|Red':'Red|Blue');

    /* ===== Leaderboard ===== */
    const board = JSON.parse(localStorage.getItem('pp_board')||'[]');
    function storeScore(){ board.push({ ts:Date.now(), score:playerScore, mode }); localStorage.setItem('pp_board', JSON.stringify(board)); }
    function renderBoard(){
      const list=document.getElementById('boardList'); list.innerHTML='';
      const top=board.slice().sort((a,b)=>b.score-a.score).slice(0,10);
      if(!top.length){ list.innerHTML='<li>No scores yet ‚Äî play a round!</li>'; return; }
      top.forEach((r,i)=>{ const li=document.createElement('li'); const d=new Date(r.ts); li.textContent=`#${i+1}  ${r.score} ‚Äî ${r.mode.toUpperCase()} ‚Äî ${d.toLocaleDateString()} ${d.toLocaleTimeString()}`; list.appendChild(li); });
    }

    /* ===== Gameplay (mobile-first) ===== */
    const BORDER=16, PADDLE_W=16, PADDLE_H0=120, CPU_H0=120;
    const player={x:BORDER+8, y:H/2-PADDLE_H0/2, w:PADDLE_W, h:PADDLE_H0};
    const cpu   ={x:W-(BORDER+8)-PADDLE_W, y:H/2-CPU_H0/2,   w:PADDLE_W, h:CPU_H0};

    let running=false, counting=false, mode='regular';
    let playerScore=0, cpuScore=0;

    // Speed profile (mobile friendly)
    const SPEED_BASE=1.9, SPEED_STEP=1.05, SPEED_MAX=5.8;

    // Ball list (supports multiball)
    /** @type {Array<{x:number,y:number,r:number,vx:number,vy:number,speed:number,stuck?:boolean}>} */
    let balls = [];

    // Power-ups (Arcade only)
    /** @type {Array<{x:number,y:number,vy:number,type:string,ttl:number}>} */
    const powerups = [];
    const PU = {
      PADDLE_MINUS_CPU: 'PADDLE_MINUS_CPU',
      MULTIBALL: 'MULTIBALL',
      STICKY: 'STICKY',
      REVERSE_AI: 'REVERSE_AI'
    };
    let puSpawnTimer = 0;

    // Timed effects
    const effects = {
      cpuShrink: 0,      // frames remaining
      reverseAI: 0,      // frames remaining
      stickyReady: 0     // 1 = next player hit catches; >1 used as timer when stuck
    };

    // Sound (subtle/no-op on some mobile browsers)
    const BLIP='data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';
    const audio={ hit:new Audio(BLIP), wall:new Audio(BLIP), score:new Audio(BLIP), pu:new Audio(BLIP) };
    function play(a){ if(settings.sound){ try{ a.currentTime=0; a.play(); }catch{} } }

    // Helpers
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const rand=(a,b)=>Math.random()*(b-a)+a;
    const randSign=()=>Math.random()<.5?-1:1;

    function makeBall(dir=randSign()){
      const speed=SPEED_BASE;
      const ang=rand(-0.26,0.26);
      return { x:W/2, y:H/2, r:11, vx:speed*dir*Math.cos(ang), vy:speed*Math.sin(ang), speed };
    }

    function resetRound(dir=randSign()){
      balls = [ makeBall(dir) ];
    }

    function themeColors(){
      const BLUE = { ground:'#1c3f82', light:'#2553aa' };
      const RED  = { ground:'#8b1c2a', light:'#b02a3a' };
      const left = themeLR==='blue|red' ? BLUE : RED;
      const right= themeLR==='blue|red' ? RED  : BLUE;
      return {
        left, right,
        line: 'rgba(255,255,255,.92)',
        paddleFill: 'rgba(255,255,255,.22)',
        border: '#ffffff'
      };
    }

    function drawCourtBackground(){
      const th = themeColors();
      ctx.fillStyle='#0b0f15'; ctx.fillRect(0,0,W,H);
      const x = BORDER, y = BORDER, w = W-2*BORDER, h = H-2*BORDER;
      ctx.fillStyle = th.left.ground;  ctx.fillRect(x, y, w/2, h);
      ctx.fillStyle = th.right.ground; ctx.fillRect(x+w/2, y, w/2, h);
      ctx.fillStyle = th.left.light;  ctx.fillRect(x, y + h*0.25, w/2, h*0.5);
      ctx.fillStyle = th.right.light; ctx.fillRect(x+w/2, y + h*0.25, w/2, h*0.5);
      ctx.lineWidth=3; ctx.strokeStyle=th.border; ctx.strokeRect(x, y, w, h);
      ctx.setLineDash([10,14]); ctx.strokeStyle=th.line; ctx.beginPath(); ctx.moveTo(W/2, y); ctx.lineTo(W/2, y+h); ctx.stroke(); ctx.setLineDash([]);
      canvas.style.borderColor = th.border;
    }

    function draw(){
      drawCourtBackground();
      const th = themeColors();

      // paddles
      ctx.fillStyle = th.paddleFill;
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.fillRect(cpu.x,    cpu.y,    cpu.w,    cpu.h);

      // balls
      ctx.fillStyle = '#f5e04c';
      for(const b of balls){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

      // power-ups (arcade only)
      if(mode==='arcade'){
        for(const pu of powerups){
          ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=2;
          ctx.strokeRect(pu.x-12, pu.y-12, 24, 24);
          ctx.fillStyle='#e6f1ff'; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
          const icon = pu.type===PU.PADDLE_MINUS_CPU ? '‚àí'
                     : pu.type===PU.MULTIBALL       ? '√ó2'
                     : pu.type===PU.STICKY          ? '‚ö™'
                     : /* REVERSE_AI */               '‚ÜîÔ∏é';
          ctx.fillText(icon, pu.x, pu.y+1);
        }
      }
    }

    function paddleBounce(b, p, isPlayer){
      // sticky handling (player-only) ‚Äî if stickyReady == 2, we're currently stuck
      if(isPlayer && effects.stickyReady === 2){
        // keep ball glued to paddle front; small bob
        b.x = p.x + p.w + b.r + 0.5;
        b.y = clamp(b.y, p.y + b.r, p.y + p.h - b.r);
        return; // no normal bounce while stuck
      }

      // Normal bounce + speed ramp
      const rel = (b.y - (p.y + p.h/2)) / (p.h/2); // -1..1
      b.speed = Math.min(b.speed * 1.05, SPEED_MAX);
      const dir = isPlayer ? 1 : -1;
      const ang = rel * 0.7;
      b.vx = b.speed * dir * Math.cos(ang);
      b.vy = b.speed * Math.sin(ang);
      b.x  = isPlayer ? p.x + p.w + b.r + 0.5 : p.x - b.r - 0.5;

      // If sticky is armed (1), catch now
      if(isPlayer && effects.stickyReady === 1){
        effects.stickyReady = 2; // enter stuck state
        b.stuck = true;
        // auto-release after short delay with angle from current rel
        setTimeout(()=>{
          if(b.stuck){
            b.stuck = false;
            effects.stickyReady = 0;
            // give it a clean launch
            const ang2 = clamp(rel, -0.9, 0.9) * 0.7;
            b.speed = Math.max(b.speed, SPEED_BASE*1.1);
            b.vx = b.speed * 1 * Math.cos(ang2);
            b.vy = b.speed * Math.sin(ang2);
          }
        }, 420);
      }

      play(audio.hit);
    }

    function update(){
      if(!running || counting) return;

      // Move power-ups (arcade)
      if(mode==='arcade'){
        puSpawnTimer++;
        if(puSpawnTimer > 90){ // ~ periodic spawn window
          puSpawnTimer = 0;
          if(Math.random() < 0.07){
            const types = [PU.PADDLE_MINUS_CPU, PU.MULTIBALL, PU.STICKY, PU.REVERSE_AI];
            powerups.push({ x: rand(BORDER+40, W-BORDER-40), y: BORDER+40, vy: 1.1, type: types[Math.floor(Math.random()*types.length)], ttl: 20*60 });
          }
        }
        for(let i=powerups.length-1;i>=0;i--){
          const pu = powerups[i];
          pu.y += pu.vy; pu.ttl--;
          if(pu.ttl<=0 || pu.y>H-BORDER-20){ powerups.splice(i,1); continue; }
          // collect by player paddle
          if(pu.x>player.x && pu.x<player.x+player.w && pu.y>player.y && pu.y<player.y+player.h){
            applyPowerup(pu.type);
            powerups.splice(i,1);
            play(audio.pu);
          }
        }
      } else {
        powerups.length = 0;
        effects.cpuShrink = effects.reverseAI = effects.stickyReady = 0;
      }

      // AI modifiers (timed effects)
      if(effects.cpuShrink>0){
        effects.cpuShrink--;
        cpu.h = CPU_H0 * 0.7;
      } else {
        cpu.h = CPU_H0;
      }
      if(effects.reverseAI>0) effects.reverseAI--;

      // Move balls
      for(const b of balls){
        // If currently stuck to player, pin position to paddle front and skip physics
        if(b.stuck){
          b.x = player.x + player.w + b.r + 0.5;
          b.y = clamp(b.y, player.y + b.r, player.y + player.h - b.r);
          continue;
        }

        b.x += b.vx; b.y += b.vy;

        // walls
        if(b.y - b.r < BORDER){ b.y = BORDER + b.r; b.vy *= -1; play(audio.wall); }
        if(b.y + b.r > H - BORDER){ b.y = H - BORDER - b.r; b.vy *= -1; play(audio.wall); }

        // paddles
        if(b.x - b.r < player.x + player.w && b.y > player.y && b.y < player.y + player.h){
          paddleBounce(b, player, true);
        }
        if(b.x + b.r > cpu.x && b.y > cpu.y && b.y < cpu.y + cpu.h){
          paddleBounce(b, cpu, false);
        }
      }

      // scoring / cleanup
      for(let i=balls.length-1;i>=0;i--){
        const b = balls[i];
        if(b.x < 0){ // CPU scored
          cpuScore++; play(audio.score);
          balls.splice(i,1);
        } else if(b.x > W){ // Player scored
          playerScore++; play(audio.score);
          balls.splice(i,1);
        }
      }
      // if no balls remain, reset round and restart after countdown
      if(balls.length===0){
        resetRound(randSign());
        startCountdown(()=>{ running=true; });
      }

      // Simple AI: follows the nearest ball (by x distance), with optional reverse control
      const targetBall = balls.reduce((best,b)=> Math.abs(W-b.x) < Math.abs(W-(best?.x??W)) ? b : best, null);
      const tb = targetBall || { y:H/2, vy:0 };
      const desired = tb.y - cpu.h/2 + clamp(tb.vy*10, -60, 60);
      const ease   = 0.05 + (Math.max(...balls.map(b=>b.speed)) - SPEED_BASE)*0.02;
      const delta  = (desired - cpu.y) * ease;
      cpu.y += (effects.reverseAI>0 ? -delta : delta);
      cpu.y = clamp(cpu.y, BORDER, H - BORDER - cpu.h);

      // Clamp player
      player.y = clamp(player.y, BORDER, H - BORDER - player.h);

      // HUD
      scoreEl.textContent = `${playerScore}:${cpuScore}`;
    }

    function applyPowerup(type){
      switch(type){
        case PU.PADDLE_MINUS_CPU:
          effects.cpuShrink = Math.max(effects.cpuShrink, 8*60); // 8s
          break;
        case PU.MULTIBALL:
          if(balls.length < 3){
            // clone the fastest ball to keep it spicy
            const src = balls.reduce((a,b)=> (a.speed||0) > (b.speed||0) ? a : b, balls[0]);
            const nb = { ...src, r: src.r, speed: Math.max(src.speed*0.95, SPEED_BASE*1.1) };
            // slight angle change
            const ang = Math.atan2(nb.vy, nb.vx) + rand(-0.35, 0.35);
            const v   = nb.speed;
            nb.vx = v * Math.cos(ang);
            nb.vy = v * Math.sin(ang);
            balls.push(nb);
          }
          break;
        case PU.STICKY:
          // arm sticky for the next player hit
          if(effects.stickyReady === 0) effects.stickyReady = 1;
          break;
        case PU.REVERSE_AI:
          effects.reverseAI = Math.max(effects.reverseAI, 6*60); // 6s
          break;
      }
    }

    function drawAndLoop(){
      update(); draw(); requestAnimationFrame(drawAndLoop);
    }
    requestAnimationFrame(drawAndLoop);

    /* ===== Start/Countdown ===== */
    function startGame(){
      show('game');
      playerScore=cpuScore=0;
      player.y=H/2-PADDLE_H0/2; cpu.y=H/2-CPU_H0/2;
      effects.cpuShrink = effects.reverseAI = effects.stickyReady = 0;
      powerups.length = 0; puSpawnTimer = 0;
      resetRound(randSign());
      running=false;
      startCountdown(()=>{ running=true; });
    }

    function startCountdown(done){
      counting=true; running=false;
      let n=3;
      countNum.textContent=n;
      countdown.classList.add('show');
      const t=setInterval(()=>{
        n--;
        if(n>0){ countNum.textContent=n; }
        else {
          clearInterval(t);
          countNum.textContent='GO!';
          setTimeout(()=>{ countdown.classList.remove('show'); counting=false; done&&done(); }, 450);
        }
      }, 700);
    }

    /* ===== Input (touch-first) ===== */
    const ptrY = e => (e.touches? e.touches[0].clientY : e.clientY) - canvas.getBoundingClientRect().top;
    let dragging=false, oy=0, py=0;
    function startDrag(e){ dragging=true; oy=ptrY(e); py=player.y; }
    function moveDrag(e){ if(!dragging) return; player.y = py + (ptrY(e)-oy); }
    function endDrag(){ dragging=false; }

    canvas.addEventListener('touchstart', startDrag, {passive:true});
    canvas.addEventListener('touchmove',  moveDrag,  {passive:true});
    canvas.addEventListener('touchend',   endDrag,   {passive:true});
    canvas.addEventListener('mousedown',  startDrag);
    canvas.addEventListener('mousemove',  moveDrag);
    window.addEventListener('mouseup',    endDrag);

    // Minimal keyboard support (desktop testing)
    window.addEventListener('keydown', e=>{
      if(e.key==='ArrowUp')   player.y -= 28;
      if(e.key==='ArrowDown') player.y += 28;
      if(e.key===' ' && !counting) running = !running;
      if(e.key==='Escape'){ running=false; show('home'); }
    });
  })();
  </script>
</body>
</html>
